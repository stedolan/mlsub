let f = fn (x) { x, x }; f
> let f = fn (x) { <err> }; f
> typechecking error: Failure("bad exp")

let x = 1; (let y = 2 2; {x,y})
> let x = 1; (<err>)
> typechecking error: Failure("bad exp")

fn (id : [A]. A -> A) { id(42) }
> fn (<err>) { id(42) }
> typechecking error: Failure("bad pat")

fn(x, y, ~k: int) { (x:int,k,y) }
> fn (x, y, ~k : int) { (<err>) }
> typechecking error: Failure("bad exp")


fn (x)
> parser failure: bad parse


# paren insertion
fn(a) { { foo: if true { fn(x) { x } } else { a } } }
> fn (a) { {foo: if true { fn (x) { x } } else { a }} }
>   fn [A, B](a: B) -> {foo: ((A) -> A) | B} {
>     {foo: if true { fn [A_2](x: A_2) -> A_2 { x } } else { a }}
>   }
> [A, B] (B) -> {foo: ((A) -> A) | B}

fn[A,B](x:A) -> A | (A) -> B { x }
> fn [A, B](x: A) -> A | (A) -> B { x }
>   fn [A, B](x: A) -> ((A) -> B) | A { x }
> [A, B] (A) -> ((A) -> B) | A

: [A <: ([] int) -> int ] A <: int
> typechecking error: Failure("bounds must be simple")
> STATS: fix: 0, flex: 103
