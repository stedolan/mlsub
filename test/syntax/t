let f = fn (x) { x, x }; f
> let f = fn (x) { <err> }; f
> test:1: syntax error
>   let f = fn (x) { x, x }; f
>                     ^

let x = 1; (let y = 2 2; {x,y})
> let x = 1; (<err>)
> test:1: syntax error
>   let x = 1; (let y = 2 2; {x,y})
>                         ^

fn (id : [A]. A -> A) { id(42) }
> fn (<err>) { id(42) }
> test:1: syntax error
>   fn (id : [A]. A -> A) { id(42) }
>               ^

fn(x, y, ~k: int) { (x:int,k,y) }
> fn (x, y, ~k : int) { (<err>) }
> test:1: syntax error
>   fn(x, y, ~k: int) { (x:int,k,y) }
>                             ^


fn (x)
> parser failure: bad parse


# paren insertion
fn(a) { { foo: if true { fn(x) { x } } else { a } } }
> fn (a) { {foo: if true { fn (x) { x } } else { a }} }
>   fn [A, B](a: A) -> {foo: ((B) -> B) | A} {
>     {foo: if true { fn [A_2](x: A_2) -> A_2 { x } } else { a }}
>   }
> [A, B] (A) -> {foo: ((B) -> B) | A}
> let  = %yield(0: fun (a) ret {
>   let k(x) = {
>     ret((foo: x))
>   };
>   match <true> {
>     true() -> {
>       k(fun (x) ret2 { ret2(x) })
>     };
>     false() -> {
>       k(a)
>     }
>   }
> });
> done

fn[A,B](x:A) -> A | (A) -> B { x }
> fn [A, B](x: A) -> A | (A) -> B { x }
>   fn [A, B](x: A) -> ((A) -> B) | A { x }
> [A, B] (A) -> ((A) -> B) | A
> let  = %yield(0: fun (x) ret { ret(x) }); done

: [A <: ([] int) -> int ] A <: int
> test:1: Bounds must be simple types
>   : [A <: ([] int) -> int ] A <: int
>           ^^^^^^^^^^^^^^^
> STATS: fix: 0, flex: 63
