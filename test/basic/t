#
# Literals
#

0
> 0
>   0
> int

5
> 5
>   5
> int

true
> true
>   true
> bool

false
> false
>   false
> bool

# FIXME: string syntax
# FIXME: interesting numeric literals (negative, hex, float, etc.)

# checking forms

(42 : int)
> (42 : int)
>   (42 : int)
> int

(true : bool)
> (true : bool)
>   (true : bool)
> bool

(42 : string)
> (42 : string)
> test:1: Type error
>   (42 : string)
>    ^^
> The type int does not match type string from test:1:
>   (42 : string)
>         ^^^^^^

#
# If
#

if (true) { 1 } else { 2 }
> if (true) { 1 } else { 2 }
>   if (true) { 1 } else { 2 }
> int

if (false) { 1 } else { false }
> if (false) { 1 } else { false }
>   if (false) { 1 } else { false }
> int | bool

#
# Tuples
#

(1, 2)
> (1, 2)
>   (1, 2)
> (int, int)

(true, 3, 4)
> (true, 3, 4)
>   (true, 3, 4)
> (bool, int, int)

# python-style singleton tuples
(4,)
> (4,)
>   (4,)
> (int,)

{foo:1}
> {foo: 1}
>   {foo: 1}
> {foo: int}

# not a singleton tuple
(1)
> (1)
>   (1)
> int

# arity
((1,),(2,3),(4,5,6),(7,8,9,10))
> ((1,), (2, 3), (4, 5, 6), (7, 8, 9, 10))
>   ((1,), (2, 3), (4, 5, 6), (7, 8, 9, 10))
> ((int,), (int, int), (int, int, int), (int, int, int, int))

# empty tuple (unit type)
()
> ()
>   ()
> ()

# trailing comma in types, too
((1,) : (int,))
> ((1,) : (int,))
>   ((1,) : (int,))
> (int,)

((1,) : (int))
> ((1,) : (int))
> test:1: Type error
>   ((1,) : (int))
>    ^^^^
> The type (_,) does not match type int from test:1:
>   ((1,) : (int))
>            ^^^

# and patterns
let (x,) = (1,); {x}
> let (x,) = (1,); {x}
>   let (x,) : (int,) = (1,); {x}
> {x: int}

let (x) = (1,); {x}
> let (x) = (1,); {x}
>   let (x) : (int,) = (1,); {x}
> {x: (int,)}

# named fields
({foo:20, bar:17}, {baz:1})
> ({foo: 20, bar: 17}, {baz: 1})
>   ({foo: 20, bar: 17}, {baz: 1})
> ({foo: int, bar: int}, {baz: int})

# joins
if (true) { (1, 2) } else { (1, true, 3) }
> if (true) { (1, 2) } else { (1, true, 3) }
>   if (true) { (1, 2) } else { (1, true, 3) }
> (int, int | bool, ...)

if (false) { {foo:1,bar:2} } else { {foo:1,baz:()} }
> if (false) { {foo: 1, bar: 2} } else { {foo: 1, baz: ()} }
>   if (false) { {foo: 1, bar: 2} } else { {foo: 1, baz: ()} }
> {foo: int, ...}

((1,2,3) : (int,int))
> ((1, 2, 3) : (int, int))
> typechecking error: Failure("extra")

((1,2,asdf) : (int, int, ...))
> ((1, 2, asdf) : (int, int, ...))
> test:1: Unknown variable name: asdf

((1,2,3) : (int, int, ...))
> ((1, 2, 3) : (int, int, ...))
>   ((1, 2, (3 : int)) : (int, int, ...))
> (int, int, ...)


true.foo
> true.foo
> test:1: Type error
>   true.foo
>   ^^^^^^^^
> The type bool does not match type {foo: _, ...}

@bot
> @bot
>   @bot
> nothing

# checking join of functions and meet of records
if true { (@bot : (~foo:(int,int), ~bar:any) -> string) } else { (@bot : (~foo:(int,int), ~bar:any) -> string) }
> if true {
>   (@bot : (~foo: (int, int), ~bar: any) -> string)
> } else {
>   (@bot : (~foo: (int, int), ~bar: any) -> string)
> }
>   if true {
>     (@bot : (~foo: (int, int), ~bar: any) -> string)
>   } else {
>     (@bot : (~foo: (int, int), ~bar: any) -> string)
>   }
> (~foo: (int, int), ~bar: any) -> string

if true { (@bot : ((int,any), ~foo:(int,int), ~bar:any) -> string) } else {(@bot : ((any,string), ~bar:string, ~foo:(string,any)) -> nothing)}
> if true {
>   (@bot : ((int, any), ~foo: (int, int), ~bar: any) -> string)
> } else {
>   (@bot : ((any, string), ~bar: string, ~foo: (string, any)) -> nothing)
> }
>   if true {
>     (@bot : ((int, any), ~foo: (int, int), ~bar: any) -> string)
>   } else {
>     (@bot : ((any, string), ~bar: string, ~foo: (string, any)) -> nothing)
>   }
> ((int, string), ~foo: (nothing, int), ~bar: string) -> string


#
# Bidirectional typing. @true and @false have only checking forms.
#

@true
> @true
> typechecking error: Failure("pragma: true")

(@true : bool)
> (@true : bool)
>   (@true : bool)
> bool

((@true, @false) : (bool, bool))
> ((@true, @false) : (bool, bool))
>   ((@true, @false) : (bool, bool))
> (bool, bool)

((1, 2) : (int, int, int))
> ((1, 2) : (int, int, int))
> typechecking error: Failure("missing .2")

((1, 2, 3) : (int, int))
> ((1, 2, 3) : (int, int))
> typechecking error: Failure("extra")

# weird. Should I allow this? eta-expansion?
# (1, 2, ...)
# > * ⊢ (int, int, ...)

((1, 2) : (int, int, ...))
> ((1, 2) : (int, int, ...))
>   ((1, 2) : (int, int, ...))
> (int, int, ...)

((1, 2, 3) : (int, int, ...))
> ((1, 2, 3) : (int, int, ...))
>   ((1, 2, (3 : int)) : (int, int, ...))
> (int, int, ...)


# A checking form for projections! Isn't subtyping great?
({foo: @true}.foo : bool)
> ({foo: @true}.foo : bool)
>   ({foo: @true}.foo : bool)
> bool

# Generalisation of functions allows checking against inferred argument types
(fn(x) { if x.cond { 1 } else { 2 }})({cond: @true})
> (fn (x) { if x.cond { 1 } else { 2 } })({cond: @true})
>   (fn (x: {cond: bool, ...}) -> int { if x.cond { 1 } else { 2 } })(
>     {cond: @true}
>   )
> int

(fn(g) { if g () {1} else {2}})(fn() { @true })
> (fn (g) { if g() { 1 } else { 2 } })(fn () { @true })
>   (fn (g: () -> bool) -> int { if g() { 1 } else { 2 } })(fn () { @true })
> int

#
# Let-bindings and patterns
#

let x = 1; x
> let x = 1; x
>   let x : int = 1; x
> int

(let x = @true; x : bool)
> (let x = @true; x : bool)
> typechecking error: Failure("pragma: true")

(let x : bool = @true; (x, @false) : (bool,bool))
> (let x : bool = @true; (x, @false) : (bool, bool))
>   (let x : bool = @true; (x, @false) : (bool, bool))
> (bool, bool)

let x = (1, 2); x
> let x = (1, 2); x
>   let x : (int, int) = (1, 2); x
> (int, int)

let x : int = (1, 2); x
> let x : int = (1, 2); x
> test:1: Type error
>   let x : int = (1, 2); x
>                 ^^^^^^
> The type (_, _) does not match type int from test:1:
>   let x : int = (1, 2); x
>           ^^^

let x : bool = true; x
> let x : bool = true; x
>   let x : bool = true; x
> bool

let x : bool = 5; x
> let x : bool = 5; x
> test:1: Type error
>   let x : bool = 5; x
>                  ^
> The type int does not match type bool from test:1:
>   let x : bool = 5; x
>           ^^^^

let {x: foo, y: bar} = {x: 10, y: true}; (foo, bar)
> let {x: foo, y: bar} = {x: 10, y: true}; (foo, bar)
>   let {x: foo, y: bar} : {x: int, y: bool} = {x: 10, y: true}; (foo, bar)
> (int, bool)

let {x: foo, y: bar} = {x: 10, y: true, z: 42}; (foo, bar)
> let {x: foo, y: bar} = {x: 10, y: true, z: 42}; (foo, bar)
> test:1: A surplus field 'z' is present.
>   let {x: foo, y: bar} = {x: 10, y: true, z: 42}; (foo, bar)
>       ^^^^^^^^^^^^^^^^
> The type {x: _, y: _, z: _} from test:1:
>   let {x: foo, y: bar} = {x: 10, y: true, z: 42}; (foo, bar)
>                          ^^^^^^^^^^^^^^^^^^^^^^^
> does not match type {x: _, y: _}

let {x: foo, y: bar, ...} = {x: 10, y: true, z: 42}; (foo, bar)
> let {x: foo, y: bar, ...} = {x: 10, y: true, z: 42}; (foo, bar)
>   let {x: foo, y: bar, ...} : {x: int, y: bool, ...} = {x: 10, y: true, z: 42};
>   (foo, bar)
> (int, bool)


# Tuple bindings

let (x, y) = (1, true); (y, x)
> let (x, y) = (1, true); (y, x)
>   let (x, y) : (int, bool) = (1, true); (y, x)
> (bool, int)

let (x, y, ...) = (false, (), 3); {x,y}
> let (x, y, ...) = (false, (), 3); {x, y}
>   let (x, y, ...) : (bool, (), ...) = (false, (), 3); {x, y}
> {x: bool, y: ()}


let {x: foo, y: bar} : {x:int, y:bool} = {x:1, y:true}; foo
> let {x: foo, y: bar} : {x: int, y: bool} = {x: 1, y: true}; foo
>   let {x: foo, y: bar} : {x: int, y: bool} = {x: 1, y: true}; foo
> int
let {x: foo, y: bar} : {x:int} = {x:1, y:true}; foo
> let {x: foo, y: bar} : {x: int} = {x: 1, y: true}; foo
> typechecking error: Failure("extra")
let {x: foo, y: bar} : {x:int,y:int} = {x:1, y:true}; foo
> let {x: foo, y: bar} : {x: int, y: int} = {x: 1, y: true}; foo
> test:1: Type error
>   let {x: foo, y: bar} : {x:int,y:int} = {x:1, y:true}; foo
>                                                  ^^^^
> The type bool does not match type int from test:1:
>   let {x: foo, y: bar} : {x:int,y:int} = {x:1, y:true}; foo
>                                   ^^^
let {x: foo, y: bar} : {x:int,y:bool,z:bool} = {x:1, y:true}; foo
> let {x: foo, y: bar} : {x: int, y: bool, z: bool} = {x: 1, y: true}; foo
> typechecking error: Failure("missing z")

# punning

let {x, y} : {x:int, y:bool} = {x:1, y:true}; (y,x)
> let {x, y} : {x: int, y: bool} = {x: 1, y: true}; (y, x)
>   let {x, y} : {x: int, y: bool} = {x: 1, y: true}; (y, x)
> (bool, int)

let {x, y} = {x:1, y:true}; (y,x)
> let {x, y} = {x: 1, y: true}; (y, x)
>   let {x, y} : {x: int, y: bool} = {x: 1, y: true}; (y, x)
> (bool, int)

let {x, y} = {x:1, y:true}; {y,x,z:3}
> let {x, y} = {x: 1, y: true}; {y, x, z: 3}
>   let {x, y} : {x: int, y: bool} = {x: 1, y: true}; {y, x, z: 3}
> {y: bool, x: int, z: int}

let {x, y} = {x:1, y:true}; ({y,x,z:3} : {y: bool, x: int, z: int})
> let {x, y} = {x: 1, y: true}; ({y, x, z: 3} : {y: bool, x: int, z: int})
>   let {x, y} : {x: int, y: bool} = {x: 1, y: true};
>   ({y, x, z: 3} : {y: bool, x: int, z: int})
> {y: bool, x: int, z: int}


# subtyping checks
let a = {foo: 1, bar: 2}; let b : {foo: int, bar: int} = a; b
> let a = {foo: 1, bar: 2}; let b : {foo: int, bar: int} = a; b
>   let a : {foo: int, bar: int} = {foo: 1, bar: 2};
>   let b : {foo: int, bar: int} = a;
>   b
> {foo: int, bar: int}

let a = {foo: 1, bar: 2}; let b : {bar: int} = a; b
> let a = {foo: 1, bar: 2}; let b : {bar: int} = a; b
> test:1: A surplus field 'foo' is present.
>   let a = {foo: 1, bar: 2}; let b : {bar: int} = a; b
>                                                  ^
> The type {foo: _, bar: _} from test:1:
>   let a = {foo: 1, bar: 2}; let b : {bar: int} = a; b
>           ^^^^^^^^^^^^^^^^
> does not match type {bar: _} from test:1:
>   let a = {foo: 1, bar: 2}; let b : {bar: int} = a; b
>                                     ^^^^^^^^^^

let a = {foo: 1, bar: 2}; let b : {bar: any, ...} = a; b
> let a = {foo: 1, bar: 2}; let b : {bar: any, ...} = a; b
>   let a : {foo: int, bar: int} = {foo: 1, bar: 2};
>   let b : {bar: any, ...} = a;
>   b
> {bar: any, ...}

let a = {foo: 1, bar: 2}; let b : {bar: nothing, ...} = a; b
> let a = {foo: 1, bar: 2}; let b : {bar: nothing, ...} = a; b
> test:1: Type error
>   let a = {foo: 1, bar: 2}; let b : {bar: nothing, ...} = a; b
>                                                           ^
> The type {foo: _, bar: int} from test:1:
>   let a = {foo: 1, bar: 2}; let b : {bar: nothing, ...} = a; b
>                         ^
> does not match type {bar: nothing, ...} from test:1:
>   let a = {foo: 1, bar: 2}; let b : {bar: nothing, ...} = a; b
>                                           ^^^^^^^

# function types
fn (f: (int,int) -> int) { f(1,2) }
> fn (f: (int, int) -> int) { f(1, 2) }
>   fn (f: (int, int) -> int) -> int { f(1, 2) }
> ((int, int) -> int) -> int

fn (f: (~x:int,~y:int) -> int) { f(~x:1, ~y:2) }
> fn (f: (~x: int, ~y: int) -> int) { f(~x: 1, ~y: 2) }
>   fn (f: (~x: int, ~y: int) -> int) -> int { f(~x: 1, ~y: 2) }
> ((~x: int, ~y: int) -> int) -> int

fn (f: (~x:int,~y:int) -> int) { let x = 1; f(~x, ~y:2) }
> fn (f: (~x: int, ~y: int) -> int) { let x = 1; f(~x, ~y: 2) }
>   fn (f: (~x: int, ~y: int) -> int) -> int { let x : int = 1; f(~x, ~y: 2) }
> ((~x: int, ~y: int) -> int) -> int

fn () { (fn (~x, ~y) { {x,y} }) (~y:1, ~x:()) }
> fn () { (fn (~x, ~y) { {x, y} })(~y: 1, ~x: ()) }
>   fn () -> {x: (), y: int} {
>     (fn [A, B](~x : A, ~y : B) -> {x: A, y: B} { {x, y} })(~y: 1, ~x: ())
>   }
> () -> {x: (), y: int}

(fn (x) { x } : (int,int) -> int)
> (fn (x) { x } : (int, int) -> int)
> typechecking error: Failure("missing param")

(fn (x,y) { x } : (int) -> int)
> (fn (x, y) { x } : (int) -> int)
> typechecking error: Failure("extra param")

#
# Lambda
#

fn (a, b) { (b, a.foo) }
> fn (a, b) { (b, a.foo) }
>   fn [A, B](a: {foo: A, ...}, b: B) -> (B, A) { (b, a.foo) }
> [A, B] ({foo: A, ...}, B) -> (B, A)

fn (a, b) -> int { b }
> fn (a, b) -> int { b }
>   fn (a: any, b: int) -> int { b }
> (any, int) -> int

fn (a : int, b) -> (int, int) { (a, b) }
> fn (a: int, b) -> (int, int) { (a, b) }
>   fn (a: int, b: int) -> (int, int) { (a, b) }
> (int, int) -> (int, int)

(fn (a) { (a, @true) } : (int) -> (int, bool))
> (fn (a) { (a, @true) } : (int) -> (int, bool))
>   (fn (a) { (a, @true) } : (int) -> (int, bool))
> (int) -> (int, bool)

fn (a) { if (a.foo) { {bar: a.bar} } else { a } }
> fn (a) { if (a.foo) { {bar: a.bar} } else { a } }
>   fn [A, B <: {foo: bool, bar: A, ...}](a: B) -> {bar: A} | B {
>     if (a.foo) {
>       {bar: a.bar}
>     } else {
>       a
>     }
>   }
> [A, B <: {foo: bool, bar: A, ...}] (B) -> {bar: A} | B

(fn (a) { a })(5)
> (fn (a) { a })(5)
>   (fn [A](a: A) -> A { a })(5)
> int

# tricky: the second 5 should be checked against Top (i.e. inferred)
(fn (a,b) { a })(5,5)
> (fn (a, b) { a })(5, 5)
>   (fn [A](a: A, b: any) -> A { a })(5, 5)
> int

(fn (a,b) { a })(5,if 5 { 5 } else { 5 })
> (fn (a, b) { a })(5, if 5 { 5 } else { 5 })
> test:1: Type error
>   (fn (a,b) { a })(5,if 5 { 5 } else { 5 })
>                         ^
> The type int does not match type bool

# more tuple cases
fn (f) { (f({x:1,y:2}), f({x:1,z:2})) }
> fn (f) { (f({x: 1, y: 2}), f({x: 1, z: 2})) }
>   fn [A](f: ({x: int, ...}) -> A) -> (A, A) {
>     (f({x: 1, y: 2}), f({x: 1, z: 2}))
>   }
> [A] (({x: int, ...}) -> A) -> (A, A)

fn (x) { if x.cond { {p:1} } else { {p:2,q:1} } }
> fn (x) { if x.cond { {p: 1} } else { {p: 2, q: 1} } }
>   fn (x: {cond: bool, ...}) -> {p: int, ...} {
>     if x.cond {
>       {p: 1}
>     } else {
>       {p: 2, q: 1}
>     }
>   }
> ({cond: bool, ...}) -> {p: int, ...}

fn (x) { if x.cond { {q:2,p:1} } else { {p:2,q:1} } }
> fn (x) { if x.cond { {q: 2, p: 1} } else { {p: 2, q: 1} } }
>   fn (x: {cond: bool, ...}) -> {q: int, p: int} {
>     if x.cond {
>       {q: 2, p: 1}
>     } else {
>       {p: 2, q: 1}
>     }
>   }
> ({cond: bool, ...}) -> {q: int, p: int}

fn (x) { let {p,q,...}=x; x }
> fn (x) { let {p, q, ...} = x; x }
>   fn [A, B, C <: {p: A, q: B, ...}](x: C) -> C {
>     let {p, q, ...} : {p: A, q: B, ...} = x;
>     x
>   }
> [A, B, C <: {p: A, q: B, ...}] (C) -> C

fn (x) { let {p,q} = x; let {p,q,r} = x; {p,q} }
> fn (x) { let {p, q} = x; let {p, q, r} = x; {p, q} }
>   fn (x: nothing) -> {p: nothing, q: nothing} {
>     let {p, q} : {p: nothing, q: nothing} = x;
>     let {p, q, r} : {p: nothing, q: nothing, r: nothing} = x;
>     {p, q}
>   }
> (nothing) -> {p: nothing, q: nothing}

fn (x) { let {p,q,...} = x; let {p,q,r} = x; {p,q} }
> fn (x) { let {p, q, ...} = x; let {p, q, r} = x; {p, q} }
>   fn [A, B, C](x: {p: A, q: B, r: C}) -> {p: A, q: B} {
>     let {p, q, ...} : {p: A, q: B, ...} = x;
>     let {p, q, r} : {p: A, q: B, r: C} = x;
>     {p, q}
>   }
> [A, B, C] ({p: A, q: B, r: C}) -> {p: A, q: B}

fn (x) { let {p,q} = x; let {p,q,r,...} = x; {p,q} }
> fn (x) { let {p, q} = x; let {p, q, r, ...} = x; {p, q} }
>   fn (x: nothing) -> {p: nothing, q: nothing} {
>     let {p, q} : {p: nothing, q: nothing} = x;
>     let {p, q, r, ...} : {p: nothing, q: nothing, r: nothing, ...} = x;
>     {p, q}
>   }
> (nothing) -> {p: nothing, q: nothing}

fn (x) { let {p,q,...} = x; let {p,q,r,...} = x; {p,q} }
> fn (x) { let {p, q, ...} = x; let {p, q, r, ...} = x; {p, q} }
>   fn [A, B, C](x: {p: A, q: B, r: C, ...}) -> {p: A, q: B} {
>     let {p, q, ...} : {p: A, q: B, ...} = x;
>     let {p, q, r, ...} : {p: A, q: B, r: C, ...} = x;
>     {p, q}
>   }
> [A, B, C] ({p: A, q: B, r: C, ...}) -> {p: A, q: B}


fn(b) { (fn (a) { if (a.cond) { a } else { a } })(if true { b } else { {foo: 1, cond: false} }) }
> fn (b) {
>   (fn (a) { if (a.cond) { a } else { a } })(
>     if true { b } else { {foo: 1, cond: false} }
>   )
> }
>   fn [A <: {cond: bool, ...}](b: A) -> {foo: int, cond: bool} | A {
>     (fn [A_2 <: {cond: bool, ...}](a: A_2) -> A_2 {
>       if (a.cond) {
>         a
>       } else {
>         a
>       }
>     })(if true { b } else { {foo: 1, cond: false} })
>   }
> [A <: {cond: bool, ...}] (A) -> {foo: int, cond: bool} | A

fn(b) { if (b.cond) { b } else { {foo: 1, cond: false} } }
> fn (b) { if (b.cond) { b } else { {foo: 1, cond: false} } }
>   fn [A <: {cond: bool, ...}](b: A) -> {foo: int, cond: bool} | A {
>     if (b.cond) {
>       b
>     } else {
>       {foo: 1, cond: false}
>     }
>   }
> [A <: {cond: bool, ...}] (A) -> {foo: int, cond: bool} | A

fn(b) { if (b.cond) { b } else { {foo: 1, cond: 4} } }
> fn (b) { if (b.cond) { b } else { {foo: 1, cond: 4} } }
>   fn [A <: {cond: bool, ...}](b: A) -> {foo: int, cond: int} | A {
>     if (b.cond) {
>       b
>     } else {
>       {foo: 1, cond: 4}
>     }
>   }
> [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A

fn (x) { (x.foo, x.bar, x.foo) }
> fn (x) { (x.foo, x.bar, x.foo) }
>   fn [A, B](x: {foo: B, bar: A, ...}) -> (B, A, B) { (x.foo, x.bar, x.foo) }
> [A, B] ({foo: B, bar: A, ...}) -> (B, A, B)

fn (x) { if (x.cond) { (x.foo, x.bar) } else { (x.foo, x.foo) } }
> fn (x) { if (x.cond) { (x.foo, x.bar) } else { (x.foo, x.foo) } }
>   fn [A, B](x: {cond: bool, foo: B, bar: A, ...}) -> (B, A | B) {
>     if (x.cond) {
>       (x.foo, x.bar)
>     } else {
>       (x.foo, x.foo)
>     }
>   }
> [A, B] ({cond: bool, foo: B, bar: A, ...}) -> (B, A | B)

fn (x) { ((fn(x){x.foo})(x), (fn(x){x.foo})(x))  }
> fn (x) { ((fn (x) { x.foo })(x), (fn (x) { x.foo })(x)) }
>   fn [A](x: {foo: A, ...}) -> (A, A) {
>     (
>       (fn [A_2](x: {foo: A_2, ...}) -> A_2 { x.foo })(x),
>       (fn [A_2](x: {foo: A_2, ...}) -> A_2 { x.foo })(x)
>     )
>   }
> [A] ({foo: A, ...}) -> (A, A)

# nested constraints, garbage variables
fn (x) { (fn(y) { y.foo.bar })({foo:{bar:x}}) }
> fn (x) { (fn (y) { y.foo.bar })({foo: {bar: x}}) }
>   fn [A](x: A) -> A {
>     (fn [A_2](y: {foo: {bar: A_2, ...}, ...}) -> A_2 { y.foo.bar })(
>       {foo: {bar: x}}
>     )
>   }
> [A] (A) -> A

# Trying to make an example with meets/joins under ctors in bounds
fn (x, f, g) { ( f(x.foo), g(x.foo) ) }
> fn (x, f, g) { (f(x.foo), g(x.foo)) }
>   fn [A, B, C](x: {foo: A, ...}, f: (A) -> B, g: (A) -> C) -> (B, C) {
>     (f(x.foo), g(x.foo))
>   }
> [A, B, C] ({foo: A, ...}, (A) -> B, (A) -> C) -> (B, C)

# same example in garbage position
(fn(x) { 5 }) (fn (x, f, g) { ( f(x.foo), g(x.foo) ) })
> (fn (x) { 5 })(fn (x, f, g) { (f(x.foo), g(x.foo)) })
>   (fn (x: any) -> int { 5 })(
>     fn [A, B, C](x: {foo: A, ...}, f: (A) -> B, g: (A) -> C) -> (B, C) {
>       (f(x.foo), g(x.foo))
>     }
>   )
> int

# garbage
fn (x) { (fn (y) { 5 })(if (x.cond) { (x.a, x.b) } else { (x.b, x.a) }) }
> fn (x) { (fn (y) { 5 })(if (x.cond) { (x.a, x.b) } else { (x.b, x.a) }) }
>   fn (x: {cond: bool, a: any, b: any, ...}) -> int {
>     (fn (y: any) -> int { 5 })(if (x.cond) { (x.a, x.b) } else { (x.b, x.a) })
>   }
> ({cond: bool, a: any, b: any, ...}) -> int


fn (x) { if (x.cond) { (x.a, x.b) } else { (x.b, x.a) } }
> fn (x) { if (x.cond) { (x.a, x.b) } else { (x.b, x.a) } }
>   fn [A, B](x: {cond: bool, a: A, b: B, ...}) -> (A | B, A | B) {
>     if (x.cond) {
>       (x.a, x.b)
>     } else {
>       (x.b, x.a)
>     }
>   }
> [A, B] ({cond: bool, a: A, b: B, ...}) -> (A | B, A | B)

fn (x) { if (x.cond) { (x, 5) } else { (x, x) } }
> fn (x) { if (x.cond) { (x, 5) } else { (x, x) } }
>   fn [A <: {cond: bool, ...}](x: A) -> (A, int | A) {
>     if (x.cond) {
>       (x, 5)
>     } else {
>       (x, x)
>     }
>   }
> [A <: {cond: bool, ...}] (A) -> (A, int | A)

fn (x) { if (x.cond) { (x, 5) } else { (x, x.n) } }
> fn (x) { if (x.cond) { (x, 5) } else { (x, x.n) } }
>   fn [A, B <: {cond: bool, n: A, ...}](x: B) -> (B, int | A) {
>     if (x.cond) {
>       (x, 5)
>     } else {
>       (x, x.n)
>     }
>   }
> [A, B <: {cond: bool, n: A, ...}] (B) -> (B, int | A)

# once
fn (f, x) { f(x) }
> fn (f, x) { f(x) }
>   fn [A, B](f: (A) -> B, x: A) -> B { f(x) }
> [A, B] ((A) -> B, A) -> B

# twice!
fn (f, x) { f(f(x)) }
> fn (f, x) { f(f(x)) }
>   fn [A, B](f: (A | B) -> B, x: A) -> B { f(f(x)) }
> [A, B] ((A | B) -> B, A) -> B

# can I hit approx with nested lambda-generalisations? trickier than I thought.
fn (f) { fn(x) { (f(x), x) } }
> fn (f) { fn (x) { (f(x), x) } }
>   fn [A, B](f: (A) -> B) -> (A) -> (B, A) { fn (x: A) -> (B, A) { (f(x), x) } }
> [A, B] ((A) -> B) -> (A) -> (B, A)


# poly id as an argument!
fn (f) { (f(1), f(true)) }
> fn (f) { (f(1), f(true)) }
>   fn [A](f: (int | bool) -> A) -> (A, A) { (f(1), f(true)) }
> [A] ((int | bool) -> A) -> (A, A)

fn (f : [A] (A) -> A) { (f(1), f(true)) }
> fn (f: [A] (A) -> A) { (f(1), f(true)) }
>   fn (f: [A] (A) -> A) -> (int, bool) { (f(1), f(true)) }
> ([A] (A) -> A) -> (int, bool)

# now requires an annotation on x or f (due to hoisting & escape)
fn (x, wid : (([A] (A) -> A) -> int)) { let f = fn(a){{x:x(a),y:a}.y}; wid(f) }
> fn (x, wid: (([A] (A) -> A) -> int)) {
>   let f = fn (a) { {x: x(a), y: a}.y };
>   wid(f)
> }
> test:1: Type error
>   fn (x, wid : (([A] (A) -> A) -> int)) { let f = fn(a){{x:x(a),y:a}.y}; wid(f) }
>                                                                              ^
> The type (_) -> any from test:1:
>   fn (x, wid : (([A] (A) -> A) -> int)) { let f = fn(a){{x:x(a),y:a}.y}; wid(f) }
>                       ^
> does not match type (_) -> nothing from test:1:
>   fn (x, wid : (([A] (A) -> A) -> int)) { let f = fn(a){{x:x(a),y:a}.y}; wid(f) }
>                             ^

# with annotation
fn (x : (any)->(), wid : (([A] (A) -> A) -> int)) { wid(fn(a){{x:x(a),y:a}.y}) }
> fn (x: (any) -> (), wid: (([A] (A) -> A) -> int)) {
>   wid(fn (a) { {x: x(a), y: a}.y })
> }
>   fn (x: (any) -> (), wid: ([A] (A) -> A) -> int) -> int {
>     wid(fn (a) { {x: (x(a) : ()), y: a}.y })
>   }
> ((any) -> (), ([A] (A) -> A) -> int) -> int

# bidir version requires no annotation
fn (x, wid : (([A] (A) -> A) -> int)) { wid(fn(a){{x:x(a),y:a}.y}) }
> fn (x, wid: (([A] (A) -> A) -> int)) { wid(fn (a) { {x: x(a), y: a}.y }) }
>   fn (x: (any) -> any, wid: ([A] (A) -> A) -> int) -> int {
>     wid(fn (a) { {x: (x(a) : any), y: a}.y })
>   }
> ((any) -> any, ([A] (A) -> A) -> int) -> int


fn (x, wid : (([A <: {foo:int}] (A) -> A | {foo:int,bar:string}) -> int)) { let f = fn(a){x(a)}; wid(f) }
> fn (x, wid: (([A <: {foo: int}] (A) -> A | {foo: int, bar: string}) -> int)) {
>   let f = fn (a) { x(a) };
>   wid(f)
> }
>   fn [A, B <: {foo: int, bar: string}](
>     x: ({foo: int} | A) -> B,
>     wid: ([A_2 <: {foo: int}] (A_2) -> {foo: int, bar: string} | A_2) -> int
>   ) -> int {
>     let f : ({foo: int} | A) -> B = fn (a: {foo: int} | A) -> B { x(a) };
>     wid(f)
>   }
> [A, B <: {foo: int, bar: string}] (
>   ({foo: int} | A) -> B,
>   ([A_2 <: {foo: int}] (A_2) -> {foo: int, bar: string} | A_2) -> int
> ) -> int

fn (x, wid : (([A <: {foo:int}] (A) -> A | {foo:int,bar:string}) -> int)) { wid(fn(a){x(a)}) }
> fn (x, wid: (([A <: {foo: int}] (A) -> A | {foo: int, bar: string}) -> int)) {
>   wid(fn (a) { x(a) })
> }
>   fn (
>     x: ({foo: int}) -> {foo: int, bar: string},
>     wid: ([A <: {foo: int}] (A) -> {foo: int, bar: string} | A) -> int
>   ) -> int {
>     wid(fn (a) { x(a) })
>   }
> (({foo: int}) -> {foo: int, bar: string}, ([A <: {foo: int}] (A) -> {foo: int, bar: string} | A) -> int) -> int

fn (x, wid : (([A <: {foo:int}] (A) -> A | {foo:int,bar:string}) -> int)) { wid(x) }
> fn (x, wid: (([A <: {foo: int}] (A) -> A | {foo: int, bar: string}) -> int)) {
>   wid(x)
> }
>   fn (
>     x: ({foo: int}) -> {foo: int, bar: string},
>     wid: ([A <: {foo: int}] (A) -> {foo: int, bar: string} | A) -> int
>   ) -> int {
>     wid(x)
>   }
> (({foo: int}) -> {foo: int, bar: string}, ([A <: {foo: int}] (A) -> {foo: int, bar: string} | A) -> int) -> int

fn(f) { (fn(x) { 5 })(f(10)) }
> fn (f) { (fn (x) { 5 })(f(10)) }
>   fn (f: (int) -> any) -> int { (fn (x: any) -> int { 5 })(f(10)) }
> ((int) -> any) -> int


# FIXME: fails recheck. Is this a correct value restriction?
# # needs approx
# (fn (x) { x })(fn (x) { x })
# > (fn (x) { x })(fn (x) { x })
# > *, 0: [(#1.2) -> #1.1, any], 1: [#1.2, any], 2: [nothing, #1.1],  ⊢ #1.0
# > [A] (A) -> A

# generalised version
fn() { (fn (x) { x })(fn (x) { x }) }
> fn () { (fn (x) { x })(fn (x) { x }) }
>   fn [A]() -> (A) -> A {
>     (fn [A_2](x: A_2) -> A_2 { x })(fn [A_2](x: A_2) -> A_2 { x })
>   }
> [A] () -> (A) -> A



# tricky hoisting+cons examples
# this way around is fine: {foo:b}|a, when a is bound more deeply
fn(f) { fn(a,b) { let z = f(b); if true { {foo:b} } else { a } } }
> fn (f) { fn (a, b) { let z = f(b); if true { {foo: b} } else { a } } }
>   fn [A](f: (A) -> any) -> [A_2] (A_2, A) -> {foo: A} | A_2 {
>     fn [A_2](a: A_2, b: A) -> {foo: A} | A_2 {
>       let z : any = f(b);
>       if true {
>         {foo: b}
>       } else {
>         a
>       }
>     }
>   }
> [A] ((A) -> any) -> [A_2] (A_2, A) -> {foo: A} | A_2

# this way around is harder: {foo:a}|b, when a is bound more deeply
# hoists a to avoid an invalid Tvjoin
fn(f) { fn(a,b) { let z = f(b); if true { {foo:a} } else { b } } }
> fn (f) { fn (a, b) { let z = f(b); if true { {foo: a} } else { b } } }
>   fn [A, B](f: (A) -> any) -> (B, A) -> {foo: B} | A {
>     fn (a: B, b: A) -> {foo: B} | A {
>       let z : any = f(b);
>       if true {
>         {foo: a}
>       } else {
>         b
>       }
>     }
>   }
> [A, B] ((A) -> any) -> (B, A) -> {foo: B} | A

# no need to hoist in these cases, with no cons (because join commutes)
fn(f) { fn(a,b) { let z = f(b); if true { b } else { a } } }
> fn (f) { fn (a, b) { let z = f(b); if true { b } else { a } } }
>   fn [A](f: (A) -> any) -> [A_2] (A_2, A) -> A | A_2 {
>     fn [A_2](a: A_2, b: A) -> A | A_2 {
>       let z : any = f(b);
>       if true {
>         b
>       } else {
>         a
>       }
>     }
>   }
> [A] ((A) -> any) -> [A_2] (A_2, A) -> A | A_2

fn(f) { fn(a,b) { let z = f(b); if true { a } else { b } } }
> fn (f) { fn (a, b) { let z = f(b); if true { a } else { b } } }
>   fn [A](f: (A) -> any) -> [A_2] (A_2, A) -> A | A_2 {
>     fn [A_2](a: A_2, b: A) -> A | A_2 {
>       let z : any = f(b);
>       if true {
>         a
>       } else {
>         b
>       }
>     }
>   }
> [A] ((A) -> any) -> [A_2] (A_2, A) -> A | A_2

# type validity may require sorting rigvars
(@bot : [A, B] ((A) -> B) -> [A_2] (A_2, A) -> A | A_2)
> (@bot : [A, B] ((A) -> B) -> [A_2] (A_2, A) -> A | A_2)
>   (@bot : [A, B] ((A) -> B) -> [A_2] (A_2, A) -> A | A_2)
> [A, B] ((A) -> B) -> [A_2] (A_2, A) -> A | A_2

(@bot : [A, B] ((A) -> B) -> [A_2] (A_2, A) -> A_2 | A)
> (@bot : [A, B] ((A) -> B) -> [A_2] (A_2, A) -> A_2 | A)
>   (@bot : [A, B] ((A) -> B) -> [A_2] (A_2, A) -> A_2 | A)
> [A, B] ((A) -> B) -> [A_2] (A_2, A) -> A_2 | A

# curried choose variants. Note hoisting in last case.
fn (a) { fn(b) { if true { a } else { b } } }
> fn (a) { fn (b) { if true { a } else { b } } }
>   fn [A](a: A) -> [A_2] (A_2) -> A | A_2 {
>     fn [A_2](b: A_2) -> A | A_2 {
>       if true {
>         a
>       } else {
>         b
>       }
>     }
>   }
> [A] (A) -> [A_2] (A_2) -> A | A_2
fn (a) { fn(b) { if true { {foo:a} } else { b } } }
> fn (a) { fn (b) { if true { {foo: a} } else { b } } }
>   fn [A](a: A) -> [A_2] (A_2) -> {foo: A} | A_2 {
>     fn [A_2](b: A_2) -> {foo: A} | A_2 {
>       if true {
>         {foo: a}
>       } else {
>         b
>       }
>     }
>   }
> [A] (A) -> [A_2] (A_2) -> {foo: A} | A_2
fn (a) { fn(b) { if true { a } else { {bar:b} } } }
> fn (a) { fn (b) { if true { a } else { {bar: b} } } }
>   fn [A, B](a: A) -> (B) -> {bar: B} | A {
>     fn (b: B) -> {bar: B} | A {
>       if true {
>         a
>       } else {
>         {bar: b}
>       }
>     }
>   }
> [A, B] (A) -> (B) -> {bar: B} | A

# same, but CPS style
fn (a) { fn(b) { fn (k) { k(if true { a } else { b }) } } }
> fn (a) { fn (b) { fn (k) { k(if true { a } else { b }) } } }
>   fn [A](a: A) -> [A_2] (A_2) -> [A_3] ((A | A_2) -> A_3) -> A_3 {
>     fn [A_2](b: A_2) -> [A_3] ((A | A_2) -> A_3) -> A_3 {
>       fn [A_3](k: (A | A_2) -> A_3) -> A_3 {
>         k(if true { a } else { b })
>       }
>     }
>   }
> [A] (A) -> [A_2] (A_2) -> [A_3] ((A | A_2) -> A_3) -> A_3
fn (a) { fn(b) { fn (k) { k(if true { {foo:a} } else { b }) } } }
> fn (a) { fn (b) { fn (k) { k(if true { {foo: a} } else { b }) } } }
>   fn [A](a: A) -> [A_2] (A_2) -> [A_3] (({foo: A} | A_2) -> A_3) -> A_3 {
>     fn [A_2](b: A_2) -> [A_3] (({foo: A} | A_2) -> A_3) -> A_3 {
>       fn [A_3](k: ({foo: A} | A_2) -> A_3) -> A_3 {
>         k(if true { {foo: a} } else { b })
>       }
>     }
>   }
> [A] (A) -> [A_2] (A_2) -> [A_3] (({foo: A} | A_2) -> A_3) -> A_3
fn (a) { fn(b) { fn (k) { k(if true { a } else { {foo:b} }) } } }
> fn (a) { fn (b) { fn (k) { k(if true { a } else { {foo: b} }) } } }
>   fn [A, B](a: A) -> (B) -> [A_2] (({foo: B} | A) -> A_2) -> A_2 {
>     fn (b: B) -> [A_2] (({foo: B} | A) -> A_2) -> A_2 {
>       fn [A_2](k: ({foo: B} | A) -> A_2) -> A_2 {
>         k(if true { a } else { {foo: b} })
>       }
>     }
>   }
> [A, B] (A) -> (B) -> [A_2] (({foo: B} | A) -> A_2) -> A_2

# CPS again, applications inside if this time
fn (a) { fn(b) { fn (k) { if true { k(a) } else { k(b) } } } }
> fn (a) { fn (b) { fn (k) { if true { k(a) } else { k(b) } } } }
>   fn [A](a: A) -> [A_2] (A_2) -> [A_3] ((A | A_2) -> A_3) -> A_3 {
>     fn [A_2](b: A_2) -> [A_3] ((A | A_2) -> A_3) -> A_3 {
>       fn [A_3](k: (A | A_2) -> A_3) -> A_3 {
>         if true {
>           k(a)
>         } else {
>           k(b)
>         }
>       }
>     }
>   }
> [A] (A) -> [A_2] (A_2) -> [A_3] ((A | A_2) -> A_3) -> A_3
fn (a) { fn(b) { fn (k) { if true { k({foo:a}) } else { k(b) } } } }
> fn (a) { fn (b) { fn (k) { if true { k({foo: a}) } else { k(b) } } } }
>   fn [A](a: A) -> [A_2] (A_2) -> [A_3] (({foo: A} | A_2) -> A_3) -> A_3 {
>     fn [A_2](b: A_2) -> [A_3] (({foo: A} | A_2) -> A_3) -> A_3 {
>       fn [A_3](k: ({foo: A} | A_2) -> A_3) -> A_3 {
>         if true {
>           k({foo: a})
>         } else {
>           k(b)
>         }
>       }
>     }
>   }
> [A] (A) -> [A_2] (A_2) -> [A_3] (({foo: A} | A_2) -> A_3) -> A_3
fn (a) { fn(b) { fn (k) { if true { k(a) } else { k({foo:b}) } } } }
> fn (a) { fn (b) { fn (k) { if true { k(a) } else { k({foo: b}) } } } }
>   fn [A, B](a: A) -> (B) -> [A_2] (({foo: B} | A) -> A_2) -> A_2 {
>     fn (b: B) -> [A_2] (({foo: B} | A) -> A_2) -> A_2 {
>       fn [A_2](k: ({foo: B} | A) -> A_2) -> A_2 {
>         if true {
>           k(a)
>         } else {
>           k({foo: b})
>         }
>       }
>     }
>   }
> [A, B] (A) -> (B) -> [A_2] (({foo: B} | A) -> A_2) -> A_2

# sorta dual of curried choose
fn (f) { fn(g) { fn(x) { (f(x), g(x)) } } }
> fn (f) { fn (g) { fn (x) { (f(x), g(x)) } } }
>   fn [A, B](f: (A) -> B) -> [A_2] ((A) -> A_2) -> (A) -> (B, A_2) {
>     fn [A_2](g: (A) -> A_2) -> (A) -> (B, A_2) {
>       fn (x: A) -> (B, A_2) {
>         (f(x), g(x))
>       }
>     }
>   }
> [A, B] ((A) -> B) -> [A_2] ((A) -> A_2) -> (A) -> (B, A_2)
fn (f) { fn(g) { fn(x) { (f(x.foo), g(x)) } } }
> fn (f) { fn (g) { fn (x) { (f(x.foo), g(x)) } } }
>   fn [A, B](f: (A) -> B) ->
>     [A_2 <: {foo: A, ...}, B_2] ((A_2) -> B_2) -> (A_2) -> (B, B_2) {
>     fn [A_2 <: {foo: A, ...}, B_2](g: (A_2) -> B_2) -> (A_2) -> (B, B_2) {
>       fn (x: A_2) -> (B, B_2) {
>         (f(x.foo), g(x))
>       }
>     }
>   }
> [A, B] ((A) -> B) -> [A_2 <: {foo: A, ...}, B_2] ((A_2) -> B_2) -> (A_2) -> (B, B_2)
fn (f) { fn(g) { fn(x) { (f(x), g(x.foo)) } } }
> fn (f) { fn (g) { fn (x) { (f(x), g(x.foo)) } } }
>   fn [A, B <: {foo: A, ...}, C](f: (B) -> C) ->
>     [A_2] ((A) -> A_2) -> (B) -> (C, A_2) {
>     fn [A_2](g: (A) -> A_2) -> (B) -> (C, A_2) {
>       fn (x: B) -> (C, A_2) {
>         (f(x), g(x.foo))
>       }
>     }
>   }
> [A, B <: {foo: A, ...}, C] ((B) -> C) -> [A_2] ((A) -> A_2) -> (B) -> (C, A_2)
fn (f) { fn(g) { fn(x) { (f(x.foo), g(x.foo)) } } }
> fn (f) { fn (g) { fn (x) { (f(x.foo), g(x.foo)) } } }
>   fn [A, B](f: (A) -> B) -> [A_2] ((A) -> A_2) -> ({foo: A, ...}) -> (B, A_2) {
>     fn [A_2](g: (A) -> A_2) -> ({foo: A, ...}) -> (B, A_2) {
>       fn (x: {foo: A, ...}) -> (B, A_2) {
>         (f(x.foo), g(x.foo))
>       }
>     }
>   }
> [A, B] ((A) -> B) -> [A_2] ((A) -> A_2) -> ({foo: A, ...}) -> (B, A_2)



# Generalised variable here, for the '...'
fn (x) { if x.cond { x } else { {cond: false} } }
> fn (x) { if x.cond { x } else { {cond: false} } }
>   fn [A <: {cond: bool, ...}](x: A) -> {cond: bool} | A {
>     if x.cond {
>       x
>     } else {
>       {cond: false}
>     }
>   }
> [A <: {cond: bool, ...}] (A) -> {cond: bool} | A

fn (x) { if x.cond { x.cond } else { true } }
> fn (x) { if x.cond { x.cond } else { true } }
>   fn (x: {cond: bool, ...}) -> bool { if x.cond { x.cond } else { true } }
> ({cond: bool, ...}) -> bool

fn (f) { f(1); 42 }
> fn (f) { f(1); 42 }
>   fn (f: (int) -> ()) -> int { f(1); 42 }
> ((int) -> ()) -> int

# even this one, with A used at both variances, could maybe delete the var?
# (relying on some nonextensible logic about atomic types covering bottom)
# in any case, () : A is a stupid elaboration
# deleting is trickier here: we'd want to first constrain () <: A
fn (f) { f(1); f(2) }
> fn (f) { f(1); f(2) }
>   fn [A <: ()](f: (int) -> A) -> A { f(1); f(2) }
> [A <: ()] ((int) -> A) -> A

# fixing the above example will break this one (seems fine though?)
((fn (f) { f(1); f(2) })(fn(x){@bot}) : int)
> ((fn (f) { f(1); f(2) })(fn (x) { @bot }) : int)
>   ((fn [A <: ()](f: (int) -> A) -> A { f(1); f(2) })(fn (x) { @bot }) : int)
> int

fn(f) { fn(x) { (x, f(x)) } }
> fn (f) { fn (x) { (x, f(x)) } }
>   fn [A, B](f: (A) -> B) -> (A) -> (A, B) { fn (x: A) -> (A, B) { (x, f(x)) } }
> [A, B] ((A) -> B) -> (A) -> (A, B)

fn(x) { let y = (fn(x){x})(x); (x.foo.bar.a.b.c, y.foo.bar.a.b.c) }
> fn (x) { let y = (fn (x) { x })(x); (x.foo.bar.a.b.c, y.foo.bar.a.b.c) }
>   fn [A, B <: {foo: {bar: {a: {b: {c: A, ...}, ...}, ...}, ...}, ...}](x: B) ->
>     (A, A) {
>     let y : B = (fn [A_2](x: A_2) -> A_2 { x })(x);
>     (x.foo.bar.a.b.c, y.foo.bar.a.b.c)
>   }
> [A, B <: {foo: {bar: {a: {b: {c: A, ...}, ...}, ...}, ...}, ...}] (B) -> (A, A)

fn(x) {
  let idf = fn(x) { let y = x.foo; x };
  let choose = fn[A](x:A,y:A) { if true {x} else {y} };
  idf(choose(x,{foo:5}))
}
> fn (x) {
>   let idf = fn (x) { let y = x.foo; x };
>   let choose = fn [A](x: A, y: A) { if true { x } else { y } };
>   idf(choose(x, {foo: 5}))
> }
>   fn [A <: {foo: any, ...}](x: A) -> {foo: int} | A {
>     let idf : [A_2 <: {foo: any, ...}] (A_2) -> A_2 =
>     fn [A_2 <: {foo: any, ...}](x: A_2) -> A_2 { let y : any = x.foo; x };
>     let choose : [A_2] (A_2, A_2) -> A_2 =
>     fn [A_2](x: A_2, y: A_2) -> A_2 { if true { x } else { y } };
>     idf(choose(x, {foo: 5}))
>   }
> [A <: {foo: any, ...}] (A) -> {foo: int} | A


> STATS: fix: 69, flex: 1653
