: int <: int
> ok

: int <: bool
> _:0: Type error
>   
> The type int arising from test:1:
>   : int <: bool
>     ^^^
> does not match type bool from test:1:
>   : int <: bool
>            ^^^^

: [A] (A) -> A <: (int) -> int
> ok

: (int) -> int <: [A] (A) -> A
> _:0: Type error

: [A, B] (A, B) -> (A|B) <: [X] (X, X) -> X
> ok

: [X] (X, X) -> X <: [A, B] (A, B) -> (A|B)
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (int) -> int}
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X <: int] () -> {foo: (X) -> int, bar: (X) -> X}
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
> _:0: Type error
>   
> The type () -> {foo: (string) -> _, bar: _} arising from test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
>                                                                                            ^^^^^^
> does not match type () -> {foo: (int) -> _, bar: _} from test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
>                                                              ^^^

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y}
> error: incompat top [] <: bot []

: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y} <: [X] () -> {foo: (X) -> X, bar: (X) -> X}
> ok

# all combinations of int -> int w/ one rigid var

: [X <: int] (X) -> (X|int) <: (int) -> int
> ok
: (int) -> int <: [X <: int] (X) -> (X|int)
> ok

: [X <: int] (X) -> X <: (int) -> int
> ok
: (int) -> int <: [X <: int] (X) -> X
> error: incompat int [11-14] <: bot []

: [X] (X) -> (X|int) <: (int) -> int
> ok
: (int) -> int <: [X] (X) -> (X|int)
> error: incompat top [] <: int [3-6]

: [X] (X) -> (X) <: (int) -> int
> ok
: (int) -> int <: [X] (X) -> (X)
> error: incompat top [] <: int [3-6]



: [X <: int] (X) -> (X|bool) <: (int) -> bool
> _:0: Type error
>   
> The type (_) -> int arising from test:1:
>   : [X <: int] (X) -> (X|bool) <: (int) -> bool
>                                    ^^^
> does not match type (_) -> nothing from test:1:
>   : [X <: int] (X) -> (X|bool) <: (int) -> bool
>                                            ^^^^
: (int) -> bool <: [X <: int] (X) -> (X|bool)
> ok




: [X <: int, Y] (X) -> (Y|int) <: (int) -> int
> ok

: (int) -> int <: [X <: int, Y] (X) -> (Y|int)
> ok

: (int) -> int <: [] (int) -> int
> ok

: [A <: int] (A) -> (int, ([B] (A) -> A)) <: (int) -> (int, [A <: int] (A) -> A)
> error: incompat int [46-49] <: bot []

: (int) -> (int, [A <: int] (A) -> A) <: [A <: int] (A) -> (int, ([B] (A) -> A))
> ok

: [B <: int] (B) -> B <: [A <: int] (A) -> A
> ok

: [B <: int] (B) -> B <: [A <: int, C] (A) -> A
> ok

# Mitchell's distributivity rule, hoisted version
# (Original is not true here, because we don't hoist foralls out of function results)
: [A] ((A) -> A) -> ((A) -> A) <: [C] ([B] (B) -> B) -> ((C) -> C)
> ok
: [C] ([B] (B) -> B) -> ((C) -> C) <: [A] ((A) -> A) -> ((A) -> A)
> error: incompat top [] <: bot []



# scope escape check
: [A] ((A) -> A) -> ((A) -> A) <: ([B](B) -> B) -> ([C](C) -> C)
> error: incompat top [] <: bot []


# tricky case of spec sub & rigvars (see cnrig <> [] case in ensure_upper_matches)
: [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A <: [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A
> ok

: [A <: {cond: bool}] A <: [A <: {cond: string}] ({cond: int} | A)
> ok

: [B <: {cond: any}] B <: [A <: {cond: bool}] ({cond: int} | A)
> ok

: [A <: {cond: bool}] ((A) -> ({cond: int} | A)) <: [A <: {cond: bool}] ((A) -> ({cond: int} | A))
> ok

# found by fuzzing!
: [D, A] {bar: {p: A} | A, foo: {p: D} | A} <: 
  [D, A] {bar: {p: A} | A, foo: {p: D} | A}
> ok

: [D <: {foo: {foo: int}}, A] ({foo: A | {foo: int}} | A | D) <:
  [D <: {foo: {foo: int}}, A] ({foo: A | {foo: int}} | A | D)
> ok

: [A] ({foo: A | {foo: int}} | A) <:
  [D <: {foo: {foo: int}}] ({foo: {foo: int}} | D)
> ok

: [A] (A | {foo:int, bar:A}) <: [A] (A | {foo:int, bar:int})
> ok


: [C] (C | {bar: C}) <: [C] {bar: C}
> ok
: [C] {bar: C} <: [C <: {bar: bool}] {bar: C}
> ok
: [C] (C | {bar: C}) <: [C <: {bar: bool}] {bar: C}
> ok
> STATS: fix: 0, flex: 115
