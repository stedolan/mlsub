: int <: int
> ok

: int <: bool
> _:0: Type error
>   
>      found: int
>   expected: bool
> This int comes from test:1:
>   : int <: bool
>     ^^^
> but is used as bool at test:1:
>   : int <: bool
>            ^^^^

: [A] (A) -> A <: (int) -> int
> ok

: (int) -> int <: [A] (A) -> A
> _:0: Type error
>   
>      found: (int) -> _
>   expected: (A) -> _
> This A comes from test:1:
>   : (int) -> int <: [A] (A) -> A
>                          ^
> but is used as int at test:1:
>   : (int) -> int <: [A] (A) -> A
>      ^^^

: [A, B] (A, B) -> (A|B) <: [X] (X, X) -> X
> ok

: [X] (X, X) -> X <: [A, B] (A, B) -> (A|B)
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (int) -> int}
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X <: int] () -> {foo: (X) -> int, bar: (X) -> X}
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
> _:0: Type error
>   
>      found: () -> {foo: (string) -> _, bar: _}
>   expected: () -> {foo: (int) -> _, bar: _}
> This int comes from test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
>                                                              ^^^
> but is used as string at test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
>                                                                                            ^^^^^^

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y}
> _:0: Type error
>   
>      found: () -> {foo: (_) -> Y, bar: _}
>   expected: () -> {foo: (_) -> X, bar: _}
> This Y comes from test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y}
>                                                                                    ^
> but is used as X at test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y}
>                                                                           ^

: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y} <: [X] () -> {foo: (X) -> X, bar: (X) -> X}
> ok

# all combinations of int -> int w/ one rigid var

: [X <: int] (X) -> (X|int) <: (int) -> int
> ok
: (int) -> int <: [X <: int] (X) -> (X|int)
> ok

: [X <: int] (X) -> X <: (int) -> int
> ok
: (int) -> int <: [X <: int] (X) -> X
> _:0: Type error
>   
>      found: (_) -> int
>   expected: (_) -> X
> This int comes from test:1:
>   : (int) -> int <: [X <: int] (X) -> X
>              ^^^
> but is used as X at test:1:
>   : (int) -> int <: [X <: int] (X) -> X
>                                       ^

: [X] (X) -> (X|int) <: (int) -> int
> ok
: (int) -> int <: [X] (X) -> (X|int)
> _:0: Type error
>   
>      found: (int) -> _
>   expected: (X) -> _
> This X comes from test:1:
>   : (int) -> int <: [X] (X) -> (X|int)
>                          ^
> but is used as int at test:1:
>   : (int) -> int <: [X] (X) -> (X|int)
>      ^^^

: [X] (X) -> (X) <: (int) -> int
> ok
: (int) -> int <: [X] (X) -> (X)
> _:0: Type error
>   
>      found: (int) -> _
>   expected: (X) -> _
> This X comes from test:1:
>   : (int) -> int <: [X] (X) -> (X)
>                          ^
> but is used as int at test:1:
>   : (int) -> int <: [X] (X) -> (X)
>      ^^^



: [X <: int] (X) -> (X|bool) <: (int) -> bool
> _:0: Type error
>   
>      found: (_) -> int
>   expected: (_) -> nothing
> This int comes from test:1:
>   : [X <: int] (X) -> (X|bool) <: (int) -> bool
>                                    ^^^
> but is used as bool at test:1:
>   : [X <: int] (X) -> (X|bool) <: (int) -> bool
>                                            ^^^^
: (int) -> bool <: [X <: int] (X) -> (X|bool)
> ok




: [X <: int, Y] (X) -> (Y|int) <: (int) -> int
> ok

: (int) -> int <: [X <: int, Y] (X) -> (Y|int)
> ok

: (int) -> int <: [] (int) -> int
> ok

: [A <: int] (A) -> (int, ([B] (A) -> A)) <: (int) -> (int, [A <: int] (A) -> A)
> _:0: Type error
>   
>      found: (_) -> (_, (_) -> int)
>   expected: (_) -> (_, (_) -> nothing)
> This int comes from test:1:
>   : [A <: int] (A) -> (int, ([B] (A) -> A)) <: (int) -> (int, [A <: int] (A) -> A)
>                                                 ^^^
> but is used as nothing at test:1:
>   : [A <: int] (A) -> (int, ([B] (A) -> A)) <: (int) -> (int, [A <: int] (A) -> A)
>                                                                                 ^

: (int) -> (int, [A <: int] (A) -> A) <: [A <: int] (A) -> (int, ([B] (A) -> A))
> ok

: [B <: int] (B) -> B <: [A <: int] (A) -> A
> ok

: [B <: int] (B) -> B <: [A <: int, C] (A) -> A
> ok

# Mitchell's distributivity rule, hoisted version
# (Original is not true here, because we don't hoist foralls out of function results)
: [A] ((A) -> A) -> ((A) -> A) <: [C] ([B] (B) -> B) -> ((C) -> C)
> ok

# FIXME: error message isn't good here
: [C] ([B] (B) -> B) -> ((C) -> C) <: [A] ((A) -> A) -> ((A) -> A)
> _:0: Type error
>   
>      found: ((A) -> _) -> _
>   expected: ((A) -> _) -> _
> This A comes from test:1:
>   : [C] ([B] (B) -> B) -> ((C) -> C) <: [A] ((A) -> A) -> ((A) -> A)
>               ^
> but is used as A at test:1:
>   : [C] ([B] (B) -> B) -> ((C) -> C) <: [A] ((A) -> A) -> ((A) -> A)
>                                               ^



# scope escape check
: [A] ((A) -> A) -> ((A) -> A) <: ([B](B) -> B) -> ([C](C) -> C)
> _:0: Type error
>   
>      found: (_) -> (_) -> any
>   expected: (_) -> (_) -> nothing
> This any comes from test:1:
>   : [A] ((A) -> A) -> ((A) -> A) <: ([B](B) -> B) -> ([C](C) -> C)
>                                                           ^
> but is used as nothing at test:1:
>   : [A] ((A) -> A) -> ((A) -> A) <: ([B](B) -> B) -> ([C](C) -> C)
>                                                                 ^


# tricky case of spec sub & rigvars (see cnrig <> [] case in ensure_upper_matches)
: [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A <: [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A
> ok

: [A <: {cond: bool}] A <: [A <: {cond: string}] ({cond: int} | A)
> ok

: [B <: {cond: any}] B <: [A <: {cond: bool}] ({cond: int} | A)
> ok

: [A <: {cond: bool}] ((A) -> ({cond: int} | A)) <: [A <: {cond: bool}] ((A) -> ({cond: int} | A))
> ok

# found by fuzzing!
: [D, A] {bar: {p: A} | A, foo: {p: D} | A} <: 
  [D, A] {bar: {p: A} | A, foo: {p: D} | A}
> ok

: [D <: {foo: {foo: int}}, A] ({foo: A | {foo: int}} | A | D) <:
  [D <: {foo: {foo: int}}, A] ({foo: A | {foo: int}} | A | D)
> ok

: [A] ({foo: A | {foo: int}} | A) <:
  [D <: {foo: {foo: int}}] ({foo: {foo: int}} | D)
> ok

: [A] (A | {foo:int, bar:A}) <: [A] (A | {foo:int, bar:int})
> ok


: [C] (C | {bar: C}) <: [C] {bar: C}
> ok
: [C] {bar: C} <: [C <: {bar: bool}] {bar: C}
> ok
: [C] (C | {bar: C}) <: [C <: {bar: bool}] {bar: C}
> ok
> STATS: fix: 0, flex: 79
