: int <: int
> ok

: int <: bool
> _:0: Type error
>   
> The type int from test:1:
>   : int <: bool
>     ^^^
> does not match type bool from test:1:
>   : int <: bool
>            ^^^^

: [A] (A) -> A <: (int) -> int
> ok

: (int) -> int <: [A] (A) -> A
> _:0: Type error
>   
> The type (int) -> _ from test:1:
>   : (int) -> int <: [A] (A) -> A
>                          ^
> does not match type (A) -> _ from test:1:
>   : (int) -> int <: [A] (A) -> A
>      ^^^

: [A, B] (A, B) -> (A|B) <: [X] (X, X) -> X
> ok

: [X] (X, X) -> X <: [A, B] (A, B) -> (A|B)
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (int) -> int}
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X <: int] () -> {foo: (X) -> int, bar: (X) -> X}
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
> _:0: Type error
>   
> The type () -> {foo: (string) -> _, bar: _} from test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
>                                                              ^^^
> does not match type () -> {foo: (int) -> _, bar: _} from test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
>                                                                                            ^^^^^^

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y}
> _:0: Type error
>   
> The type () -> {foo: (Y) -> _, bar: _} from test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y}
>                                                                     ^
> does not match type () -> {foo: (X) -> _, bar: _} from test:1:
>   : [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y}
>                                                                                          ^

: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y} <: [X] () -> {foo: (X) -> X, bar: (X) -> X}
> ok

# all combinations of int -> int w/ one rigid var

: [X <: int] (X) -> (X|int) <: (int) -> int
> ok
: (int) -> int <: [X <: int] (X) -> (X|int)
> ok

: [X <: int] (X) -> X <: (int) -> int
> ok
: (int) -> int <: [X <: int] (X) -> X
> _:0: Type error
>   
> The type (_) -> int from test:1:
>   : (int) -> int <: [X <: int] (X) -> X
>              ^^^
> does not match type (_) -> X from test:1:
>   : (int) -> int <: [X <: int] (X) -> X
>                                       ^

: [X] (X) -> (X|int) <: (int) -> int
> ok
: (int) -> int <: [X] (X) -> (X|int)
> _:0: Type error
>   
> The type (int) -> _ from test:1:
>   : (int) -> int <: [X] (X) -> (X|int)
>                          ^
> does not match type (X) -> _ from test:1:
>   : (int) -> int <: [X] (X) -> (X|int)
>      ^^^

: [X] (X) -> (X) <: (int) -> int
> ok
: (int) -> int <: [X] (X) -> (X)
> _:0: Type error
>   
> The type (int) -> _ from test:1:
>   : (int) -> int <: [X] (X) -> (X)
>                          ^
> does not match type (X) -> _ from test:1:
>   : (int) -> int <: [X] (X) -> (X)
>      ^^^



: [X <: int] (X) -> (X|bool) <: (int) -> bool
> _:0: Type error
>   
> The type (_) -> int from test:1:
>   : [X <: int] (X) -> (X|bool) <: (int) -> bool
>                                    ^^^
> does not match type (_) -> nothing from test:1:
>   : [X <: int] (X) -> (X|bool) <: (int) -> bool
>                                            ^^^^
: (int) -> bool <: [X <: int] (X) -> (X|bool)
> ok




: [X <: int, Y] (X) -> (Y|int) <: (int) -> int
> ok

: (int) -> int <: [X <: int, Y] (X) -> (Y|int)
> ok

: (int) -> int <: [] (int) -> int
> ok

: [A <: int] (A) -> (int, ([B] (A) -> A)) <: (int) -> (int, [A <: int] (A) -> A)
> _:0: Type error
>   
> The type (_) -> (_, (_) -> int) from test:1:
>   : [A <: int] (A) -> (int, ([B] (A) -> A)) <: (int) -> (int, [A <: int] (A) -> A)
>                                                 ^^^
> does not match type (_) -> (_, (_) -> nothing) from test:1:
>   : [A <: int] (A) -> (int, ([B] (A) -> A)) <: (int) -> (int, [A <: int] (A) -> A)
>                                                                                 ^

: (int) -> (int, [A <: int] (A) -> A) <: [A <: int] (A) -> (int, ([B] (A) -> A))
> ok

: [B <: int] (B) -> B <: [A <: int] (A) -> A
> ok

: [B <: int] (B) -> B <: [A <: int, C] (A) -> A
> ok

# Mitchell's distributivity rule, hoisted version
# (Original is not true here, because we don't hoist foralls out of function results)
: [A] ((A) -> A) -> ((A) -> A) <: [C] ([B] (B) -> B) -> ((C) -> C)
> ok
: [C] ([B] (B) -> B) -> ((C) -> C) <: [A] ((A) -> A) -> ((A) -> A)
> _:0: Type error
>   
> The type ((A) -> _) -> _ from test:1:
>   : [C] ([B] (B) -> B) -> ((C) -> C) <: [A] ((A) -> A) -> ((A) -> A)
>               ^
> does not match type ((A) -> _) -> _ from test:1:
>   : [C] ([B] (B) -> B) -> ((C) -> C) <: [A] ((A) -> A) -> ((A) -> A)
>                                               ^



# scope escape check
: [A] ((A) -> A) -> ((A) -> A) <: ([B](B) -> B) -> ([C](C) -> C)
> _:0: Type error
>   
> The type (_) -> (_) -> any from test:1:
>   : [A] ((A) -> A) -> ((A) -> A) <: ([B](B) -> B) -> ([C](C) -> C)
>                                                           ^
> does not match type (_) -> (_) -> nothing from test:1:
>   : [A] ((A) -> A) -> ((A) -> A) <: ([B](B) -> B) -> ([C](C) -> C)
>                                                                 ^


# tricky case of spec sub & rigvars (see cnrig <> [] case in ensure_upper_matches)
: [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A <: [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A
> ok

: [A <: {cond: bool}] A <: [A <: {cond: string}] ({cond: int} | A)
> ok

: [B <: {cond: any}] B <: [A <: {cond: bool}] ({cond: int} | A)
> ok

: [A <: {cond: bool}] ((A) -> ({cond: int} | A)) <: [A <: {cond: bool}] ((A) -> ({cond: int} | A))
> ok

# found by fuzzing!
: [D, A] {bar: {p: A} | A, foo: {p: D} | A} <: 
  [D, A] {bar: {p: A} | A, foo: {p: D} | A}
> ok

: [D <: {foo: {foo: int}}, A] ({foo: A | {foo: int}} | A | D) <:
  [D <: {foo: {foo: int}}, A] ({foo: A | {foo: int}} | A | D)
> ok

: [A] ({foo: A | {foo: int}} | A) <:
  [D <: {foo: {foo: int}}] ({foo: {foo: int}} | D)
> ok

: [A] (A | {foo:int, bar:A}) <: [A] (A | {foo:int, bar:int})
> ok


: [C] (C | {bar: C}) <: [C] {bar: C}
> ok
: [C] {bar: C} <: [C <: {bar: bool}] {bar: C}
> ok
: [C] (C | {bar: C}) <: [C <: {bar: bool}] {bar: C}
> ok
> STATS: fix: 0, flex: 79
