: int <: int
> ok

: int <: bool
> typechecking error: Failure("incompat int <: bool")

: [A] (A) -> A <: (int) -> int
> ok

: (int) -> int <: [A] (A) -> A
> typechecking error: Failure("incompat top <: int")

: [A, B] (A, B) -> (A|B) <: [X] (X, X) -> X
> ok

: [X] (X, X) -> X <: [A, B] (A, B) -> (A|B)
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (int) -> int}
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X <: int] () -> {foo: (X) -> int, bar: (X) -> X}
> ok

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: () -> {foo: (int) -> int, bar: (string) -> string}
> typechecking error: Failure("incompat int <: string")

: [X] () -> {foo: (X) -> X, bar: (X) -> X} <: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y}
> typechecking error: Failure("incompat top <: bot")

: [X, Y] () -> {foo: (X) -> X, bar: (Y) -> Y} <: [X] () -> {foo: (X) -> X, bar: (X) -> X}
> ok

# all combinations of int -> int w/ one rigid var

: [X <: int] (X) -> (X|int) <: (int) -> int
> ok
: (int) -> int <: [X <: int] (X) -> (X|int)
> ok

: [X <: int] (X) -> X <: (int) -> int
> ok
: (int) -> int <: [X <: int] (X) -> X
> typechecking error: Failure("incompat int <: bot")

: [X] (X) -> (X|int) <: (int) -> int
> ok
: (int) -> int <: [X] (X) -> (X|int)
> typechecking error: Failure("incompat top <: int")

: [X] (X) -> (X) <: (int) -> int
> ok
: (int) -> int <: [X] (X) -> (X)
> typechecking error: Failure("incompat top <: int")



: [X <: int] (X) -> (X|bool) <: (int) -> bool
> typechecking error: Failure("incompat int <: bot")
: (int) -> bool <: [X <: int] (X) -> (X|bool)
> ok




: [X <: int, Y] (X) -> (Y|int) <: (int) -> int
> ok

: (int) -> int <: [X <: int, Y] (X) -> (Y|int)
> ok

: (int) -> int <: [] (int) -> int
> ok

: [A <: int] (A) -> (int, ([B] (A) -> A)) <: (int) -> (int, [A <: int] (A) -> A)
> typechecking error: Failure("incompat int <: bot")

: (int) -> (int, [A <: int] (A) -> A) <: [A <: int] (A) -> (int, ([B] (A) -> A))
> ok

: [B <: int] (B) -> B <: [A <: int] (A) -> A
> ok

: [B <: int] (B) -> B <: [A <: int, C] (A) -> A
> ok

# Mitchell's distributivity rule, hoisted version
# (Original is not true here, because we don't hoist foralls out of function results)
: [A] ((A) -> A) -> ((A) -> A) <: [C] ([B] (B) -> B) -> ((C) -> C)
> ok
: [C] ([B] (B) -> B) -> ((C) -> C) <: [A] ((A) -> A) -> ((A) -> A)
> typechecking error: Failure("incompat top <: bot")



# scope escape check
: [A] ((A) -> A) -> ((A) -> A) <: ([B](B) -> B) -> ([C](C) -> C)
> typechecking error: Failure("incompat top <: bot")


# tricky case of spec sub & rigvars (see cnrig <> [] case in ensure_upper_matches)
: [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A <: [A <: {cond: bool, ...}] (A) -> {foo: int, cond: int} | A
> ok

: [A <: {cond: bool}] A <: [A <: {cond: string}] ({cond: int} | A)
> ok

: [B <: {cond: any}] B <: [A <: {cond: bool}] ({cond: int} | A)
> ok

: [A <: {cond: bool}] ((A) -> ({cond: int} | A)) <: [A <: {cond: bool}] ((A) -> ({cond: int} | A))
> ok

# found by fuzzing!
: [D, A] {bar: {p: A} | A, foo: {p: D} | A} <: 
  [D, A] {bar: {p: A} | A, foo: {p: D} | A}
> ok

: [D <: {foo: {foo: int}}, A] ({foo: A | {foo: int}} | A | D) <:
  [D <: {foo: {foo: int}}, A] ({foo: A | {foo: int}} | A | D)
> ok

: [A] ({foo: A | {foo: int}} | A) <:
  [D <: {foo: {foo: int}}] ({foo: {foo: int}} | D)
> ok

: [A] (A | {foo:int, bar:A}) <: [A] (A | {foo:int, bar:int})
> ok


: [C] (C | {bar: C}) <: [C] {bar: C}
> ok
: [C] {bar: C} <: [C <: {bar: bool}] {bar: C}
> ok
: [C] (C | {bar: C}) <: [C <: {bar: bool}] {bar: C}
> ok
> STATS: fix: 0, flex: 115
