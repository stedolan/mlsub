fn (x, wid : (([A <: {foo:int}] (A) -> A | {foo:int,bar:string}) -> int)) { let f = fn(a){x(a)}; wid(f) }
> fn (x, wid: (([A <: {foo: int}] (A) -> A | {foo: int, bar: string}) -> int)) {
>   let f = fn (a) { x(a) };
>   wid(f)
> }
>   fn [A, B <: {foo: int, bar: string}](
>     x: ({foo: int} | A) -> B,
>     wid: ([A_2 <: {foo: int}] (A_2) -> {foo: int, bar: string} | A_2) -> int
>   ) -> int {
>     let f : ({foo: int} | A) -> B = fn (a: {foo: int} | A) -> B { x(a) };
>     wid(f)
>   }
> [A, B <: {foo: int, bar: string}] (
>   ({foo: int} | A) -> B,
>   ([A_2 <: {foo: int}] (A_2) -> {foo: int, bar: string} | A_2) -> int
> ) -> int
> let  = %yield(0: fun (x, wid) ret {
>   let f = fun (a) ret2 { let x2 = x(0: a); ret2(x2) };
>   let x2 = wid(0: f);
>   ret(x2)
> });
> done

fn (x, wid : ((any) -> any) -> int) { let f = fn(a){x(a)}; wid(f) }
> fn (x, wid: ((any) -> any) -> int) { let f = fn (a) { x(a) }; wid(f) }
>   fn [A](x: (any) -> A, wid: ((any) -> any) -> int) -> int {
>     let f : (any) -> A = fn (a: any) -> A { x(a) };
>     wid(f)
>   }
> [A] ((any) -> A, ((any) -> any) -> int) -> int
> let  = %yield(0: fun (x, wid) ret {
>   let f = fun (a) ret2 { let x2 = x(0: a); ret2(x2) };
>   let x2 = wid(0: f);
>   ret(x2)
> });
> done

fn (x) { (fn(a){x(a)})(6) }
> fn (x) { (fn (a) { x(a) })(6) }
>   fn [A, B](x: (int | A) -> B) -> B { (fn (a: int | A) -> B { x(a) })(6) }
> [A, B] ((int | A) -> B) -> B
> let  = %yield(0: fun (x) ret {
>   let x2 = fun (a) ret2 {
>     let x2 = x(0: a);
>     ret2(x2)
>   }(0: 6);
>   ret(x2)
> });
> done

fn (x) { let y = x; 1 }
> fn (x) { let y = x; 1 }
>   fn [A](x: A) -> int { let y : A = x; 1 }
> [A] (A) -> int
> let  = %yield(0: fun (x) ret { ret(1) }); done

let id=fn[A](){fn(a:A){a}}; fn(){let x=id(); x(1)}
> let id = fn [A]() { fn (a: A) { a } }; fn () { let x = id(); x(1) }
>   let id : [A] () -> (A) -> A = fn [A]() -> (A) -> A { fn (a: A) -> A { a } };
>   fn [A]() -> int | A {
>     let x : (int | A) -> int | A = id();
>     x(1)
>   }
> [A] () -> int | A
> let id = fun () ret { ret(fun (a) ret2 { ret2(a) }) };
> let  = %yield(0: fun () ret { let x = id(); let x2 = x(0: 1); ret(x2) });
> done

fn (x) -> (any) -> any { let f = fn(a){x(a)}; f }
> fn (x) -> (any) -> any { let f = fn (a) { x(a) }; f }
>   fn [A](x: (any) -> A) -> (any) -> any {
>     let f : (any) -> A = fn (a: any) -> A { x(a) };
>     f
>   }
> [A] ((any) -> A) -> (any) -> any
> let  = %yield(0: fun (x) ret {
>   let f = fun (a) ret2 { let x2 = x(0: a); ret2(x2) };
>   ret(f)
> });
> done

fn (f) { fn(g,x) { (g(x.foo), f(x)) } }
> fn (f) { fn (g, x) { (g(x.foo), f(x)) } }
>   fn [A, B <: {foo: A, ...}, C, D](f: (B) -> C) -> ((A) -> D, B) -> (D, C) {
>     fn (g: (A) -> D, x: B) -> (D, C) {
>       (g(x.foo), f(x))
>     }
>   }
> [A, B <: {foo: A, ...}, C, D] ((B) -> C) -> ((A) -> D, B) -> (D, C)
> let  = %yield(0: fun (f) ret {
>   ret(fun (g, x) ret2 {
>     let x2 = f(0: x);
>     let foo = x.(foo);
>     let x3 = g(0: foo);
>     ret2((0: x3, 1: x2))
>   })
> });
> done


let twice = fn(f, x) {f(f(x)) };
let id = fn(a) { a };
fn() { twice(id, id)(id) }
> let twice = fn (f, x) { f(f(x)) };
> let id = fn (a) { a };
> fn () {
>   twice(id, id)(id)
> }
>   let twice : [A, B] ((A | B) -> B, A) -> B =
>   fn [A, B](f: (A | B) -> B, x: A) -> B { f(f(x)) };
>   let id : [A] (A) -> A = fn [A](a: A) -> A { a };
>   fn [A]() -> (A) -> A {
>     twice(id, id)(id)
>   }
> [A] () -> (A) -> A
> let twice = fun (f, x) ret { let x2 = f(0: x); let x3 = f(0: x2); ret(x3) };
> let id = fun (a) ret { ret(a) };
> let  = %yield(0: fun () ret {
>   let x = twice(0: id, 1: id);
>   let x2 = x(0: id);
>   ret(x2)
> });
> done
> STATS: fix: 14, flex: 267
