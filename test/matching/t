
fn(x) { (Foo(), Bar, Foo{x: 42}, Baz(1)) }
> fn (x) { (Foo, Bar, Foo{x: 42}, Baz(1)) }
>   fn (x: any) -> ('Foo, 'Bar, 'Foo{x: int}, 'Baz(int)) {
>     (Foo, Bar, Foo{x: 42}, Baz(1))
>   }
> (any) -> ('Foo, 'Bar, 'Foo{x: int}, 'Baz(int))
> let  = %yield(0: fun (x) ret {
>   ret((0: Foo(), 1: Bar(), 2: Foo(x: 42), 3: Baz(0: 1)))
> });
> done

# Checking mode
( if true { Foo(@true) } else { Bar(6) }
  : 'Foo(bool) | 'Bar(int) )
> (if true { Foo(@true) } else { Bar(6) } : 'Foo(bool) | 'Bar(int))
>   (if true { Foo(@true) } else { Bar(6) } : 'Foo(bool) | 'Bar(int))
> 'Foo(bool) | 'Bar(int)
> let k(x) = {
>   let  = %yield(0: x);
>   done
> };
> match <true> {
>   true() -> {
>     k(Foo(0: <true>))
>   };
>   false() -> {
>     k(Bar(0: 6))
>   }
> }

({x: 42} : 'Foo{x: int})
> ({x: 42} : 'Foo{x: int})
> test:1: The tag should be Foo, but no tag is present.
>   ({x: 42} : 'Foo{x: int})
>    ^^^^^^^
>      found: {x: _}
>   expected: 'Foo{x: _}
> This {x: _} is used as 'Foo{x: _} at test:1:
>   ({x: 42} : 'Foo{x: int})
>              ^^^^^^^^^^^^

(Bar{x: 42} : 'Foo{x: int})
> (Bar{x: 42} : 'Foo{x: int})
> test:1: The tag should be Foo, but tag Bar is present.
>   (Bar{x: 42} : 'Foo{x: int})
>    ^^^^^^^^^^
>      found: 'Bar{x: _}
>   expected: 'Foo{x: _}
> This 'Bar{x: _} is used as 'Foo{x: _} at test:1:
>   (Bar{x: 42} : 'Foo{x: int})
>                 ^^^^^^^^^^^^

#
# Matching syntax in functions and lets
#
fn(x, x) { x }
> fn (x, x) { x }
> test:1: The variable name x is already in use:
>   fn(x, x) { x }
>         ^
> as it is previously bound here:
>   fn(x, x) { x }
>      ^

fn((A|B), x) { x }
> fn ((A | B), x) { x }
>   fn [A]((A | B): 'A | 'B, x: A) -> A { x }
> [A] ('A | 'B, A) -> A
> let  = %yield(0: fun (0, x) ret {
>   match 0 {
>     A() -> {
>       ret(x)
>     };
>     B() -> {
>       ret(x)
>     }
>   }
> });
> done

# FIXME: don't like this elaboration!
fn(x) { let (a, b, c) = x; (c, b, a) }
> fn (x) { let (a, b, c) = x; (c, b, a) }
>   fn [A, B, C, D <: (A, B, C)](x: D) -> (C, B, A) {
>     let (a, b, c) : D = x;
>     (c, b, a)
>   }
> [A, B, C, D <: (A, B, C)] (D) -> (C, B, A)
> let  = %yield(0: fun (x) ret {
>   let v0, v1, v2 = x.(0, 1, 2);
>   ret((0: v2, 1: v1, 2: v0))
> });
> done

#
# Match errors
#

fn(x) { match x { (_,_) => 1 | (_,_,_) => 2 } }
> fn (x) { match x { (_, _) => 1 | (_, _, _) => 2 } }
> test:1: This pattern:
>   fn(x) { match x { (_,_) => 1 | (_,_,_) => 2 } }
>                                  ^^^^^^^
> is incompatible with the pattern at test:1:
>   fn(x) { match x { (_,_) => 1 | (_,_,_) => 2 } }
>                     ^^^^^

fn(x) { match x { (a,a) => 1 } }
> fn (x) { match x { (a, a) => 1 } }
> test:1: The variable name a is already in use:
>   fn(x) { match x { (a,a) => 1 } }
>                        ^
> as it is previously bound here:
>   fn(x) { match x { (a,a) => 1 } }
>                      ^

fn(x) { match x, x { a, b, c => 2 } }
> fn (x) { match x, x { a, b, c => 2 } }
> test:1: Expected 2 patterns but found 3:
>   fn(x) { match x, x { a, b, c => 2 } }
>                        ^^^^^^^

fn(x) { match x { Foo => 1 | _ => 2 } }
> fn (x) { match x { Foo => 1 | _ => 2 } }
> _:0: Cannot determine which cases this pattern matches

fn(x) { match x { (a | Foo) => 1 } }
> fn (x) { match x { (a | Foo) => 1 } }
> test:1: The variable a must be bound on both sides of this or-pattern
>   fn(x) { match x { (a | Foo) => 1 } }
>                      ^^^^^^^

fn(x) { match (A(1, 2)) { A(x,C) => 1 } }
> fn (x) { match (A(1, 2)) { A(x, C) => 1 } }
> test:1: Type error
>   fn(x) { match (A(1, 2)) { A(x,C) => 1 } }
>                 ^^^^^^^^^
>      found: int
>   expected: 'C
> This int comes from test:1:
>   fn(x) { match (A(1, 2)) { A(x,C) => 1 } }
>                       ^
> but is used as 'C at test:1:
>   fn(x) { match (A(1, 2)) { A(x,C) => 1 } }
>                                 ^

fn(x : 'A(int, int) | 'B(int, int)) {
  match x {
  | A(x, y) => (x, y)
  | (a, b) => (a, b)
  }
}
> fn (x: 'A(int, int) | 'B(int, int)) {
>   match x {
>     | A(x, y) => (x, y)
>     | (a, b) => (a, b)
>   }
> }
> test:3: This pattern:
>     | A(x, y) => (x, y)
>       ^^^^^^^
> is incompatible with the pattern at test:4:
>     | (a, b) => (a, b)
>       ^^^^^^


fn(c) {
  let a = if c {Foo{x:Foo}} else {Bar{x:Bar}};
  (a, a.x)
}
> fn (c) { let a = if c { Foo{x: Foo} } else { Bar{x: Bar} }; (a, a.x) }
>   fn (c: bool) -> ('Foo{x: 'Foo} | 'Bar{x: 'Bar}, 'Foo | 'Bar) {
>     let a : 'Foo{x: 'Foo} | 'Bar{x: 'Bar} =
>     if c { Foo{x: Foo} } else { Bar{x: Bar} };
>     (a, a.x)
>   }
> (bool) -> ('Foo{x: 'Foo} | 'Bar{x: 'Bar}, 'Foo | 'Bar)
> let  = %yield(0: fun (c) ret {
>   let k(x) = {
>     let x2 = x.(x);
>     ret((0: x, 1: x2))
>   };
>   match c {
>     true() -> {
>       k(Foo(x: Foo()))
>     };
>     false() -> {
>       k(Bar(x: Bar()))
>     }
>   }
> });
> done

fn(x) {
  match x {
  | A(_, b) => b
  | B{foo: (C|D), bar:x} => x
  }
}
> fn (x) { match x { A(_, b) => b | B{foo: (C | D), bar: x} => x } }
>   fn [A, B](x: 'A(any, A) | 'B{foo: 'C | 'D, bar: B}) -> A | B {
>     match x {
>       | A(_, b) => b
>       | B{foo: (C | D), bar: x} => x
>     }
>   }
> [A, B] ('A(any, A) | 'B{foo: 'C | 'D, bar: B}) -> A | B
> let  = %yield(0: fun (x) ret {
>   match x {
>     A(0: v0,
>     1: v1) -> {
>       ret(v1)
>     };
>     B(foo: foo,
>     bar: bar) -> {
>       match foo {
>         C() -> {
>           ret(bar)
>         };
>         D() -> {
>           ret(bar)
>         }
>       }
>     }
>   }
> });
> done


fn(x) {
  match x {
  | A(_, b) => b
  | A(_, _, _) => 42
  | B{foo: (C|D), bar:x} => x
  }
}
> fn (x) {
>   match x {
>     | A(_, b) => b
>     | A(_, _, _) => 42
>     | B{foo: (C | D), bar: x} => x
>   }
> }
> test:4: This pattern:
>     | A(_, _, _) => 42
>       ^^^^^^^^^^
> is incompatible with the pattern at test:3:
>     | A(_, b) => b
>       ^^^^^^^

#
# Regression for a reversal bug
#

fn(a, b) {
  match a, b {
  | A, y => y
  | B, y => y
  }
}
> fn (a, b) { match a, b { A, y => y | B, y => y } }
>   fn [A](a: 'A | 'B, b: A) -> A { match a, b { A, y => y | B, y => y } }
> [A] ('A | 'B, A) -> A
> let  = %yield(0: fun (a, b) ret {
>   match a {
>     A() -> {
>       ret(b)
>     };
>     B() -> {
>       ret(b)
>     }
>   }
> });
> done


# FIXME: badly broken
fn() {
  match D{x:5} {
    D{x, y} => (x, y)
  }
}
> fn () { match D{x: 5} { D{x, y} => (x, y) } }
> test:3: Unknown variable name y
>       D{x, y} => (x, y)
>                      ^


# Grammar ambiguity requires parens on return type
# (otherwise function body is misread as fields)
fn(x : 'A | 'B | 'C(int) | 'D{x:int}) -> int {
  match x { A => 1 | B() => 2 | C(x) => 3 | D{x:foo, y:bar} | E(foo,bar) => 5 }
}
> fn (x: 'A | 'B | 'C(int) | 'D{x: int}) -> int {
>   match x {
>     | A => 1
>     | B => 2
>     | C(x) => 3
>     | D{x: foo, y: bar}
>     | E(foo, bar) => 5
>   }
> }
> typechecking error: Failure("unknown ctor")

# FIXME the exhaustivity checking is kinda broken here as types change
# Should either report an unused pat on case 2 or unhandled (B,B)
fn (x) {
  match x {
  | (A, A) => 1
  | (A, B) => 2
  | (B, A) => 3
  }
}
> fn (x) { match x { (A, A) => 1 | (A, B) => 2 | (B, A) => 3 } }
>   fn (x: ('A | 'B, 'A)) -> int {
>     match x {
>       | (A, A) => 1
>       | (A, B) => 2
>       | (B, A) => 3
>     }
>   }
> (('A | 'B, 'A)) -> int
> RECHECK: Failure("unknown ctor")
> 
> ELAB: Failure("unknown ctor")
> 
> ELABINF: Failure("unknown ctor")
> 
> let  = %yield(0: fun (x) ret {
>   let v0, v1 = x.(0, 1);
>   match v0 {
>     A() -> {
>       match v1 {
>         A() -> {
>           ret(1)
>         };
>         B() -> {
>           ret(2)
>         }
>       }
>     };
>     B() -> {
>       match v1 {
>         A() -> {
>           ret(3)
>         }
>       }
>     }
>   }
> });
> done


let make = fn (x) {
  if x.good {
    Good{foo: x.foo, bar: x.bar}
  } else {
    Bad{foo: x.foo}
  }
};
fn (x) {
  let y = make(x);
  (y.foo, y.bar)
}
> let make =
> fn (x) { if x.good { Good{foo: x.foo, bar: x.bar} } else { Bad{foo: x.foo} } };
> fn (x) {
>   let y = make(x);
>   (y.foo, y.bar)
> }
> test:10: The field 'bar' is missing.
>     (y.foo, y.bar)
>             ^^^^^
>      found: 'Good{foo: _, bar: _} | 'Bad{foo: _}
>   expected: {bar: _, ...}
> This 'Bad{foo: _} comes from test:5:
>       Bad{foo: x.foo}
>       ^^^^^^^^^^^^^^^
> but is used as {bar: _, ...}

let make = fn (x) {
  if x.good {
    Good{foo: x.foo, bar: x.bar}
  } else {
    Bad{foo: x.foo}
  }
};
let use = fn (y) {
  match y {
  | Good{foo: bar, ...} => bar
  | Bad{foo: bar, ...} => bar
  }
};
fn (x) { use(make(x)) }
> let make =
> fn (x) { if x.good { Good{foo: x.foo, bar: x.bar} } else { Bad{foo: x.foo} } };
> let use =
> fn (y) { match y { Good{foo: bar, ...} => bar | Bad{foo: bar, ...} => bar } };
> fn (x) {
>   use(make(x))
> }
>   let make : [A, B] ({good: bool, bar: A, foo: B, ...}) ->
>   'Good{foo: B, bar: A} | 'Bad{foo: B} =
>   fn [A, B](x: {good: bool, bar: A, foo: B, ...}) ->
>     'Good{foo: B, bar: A} | 'Bad{foo: B} {
>     if x.good {
>       Good{foo: x.foo, bar: x.bar}
>     } else {
>       Bad{foo: x.foo}
>     }
>   };
>   let use : [A, B] ('Good{foo: A, ...} | 'Bad{foo: B, ...}) -> A | B =
>   fn [A, B](y: 'Good{foo: A, ...} | 'Bad{foo: B, ...}) -> A | B {
>     match y {
>       | Good{foo: bar, ...} => bar
>       | Bad{foo: bar, ...} => bar
>     }
>   };
>   fn [A](x: {good: bool, bar: any, foo: A, ...}) -> A | A {
>     use(make(x))
>   }
> [A] ({good: bool, bar: any, foo: A, ...}) -> A | A
> let make =
>   fun (x) ret {
>     let good = x.(good);
>     match good {
>       true() -> {
>         let bar = x.(bar);
>         let foo = x.(foo);
>         ret(Good(foo: foo, bar: bar))
>       };
>       false() -> {
>         let foo = x.(foo);
>         ret(Bad(foo: foo))
>       }
>     }
>   };
> let use =
>   fun (y) ret {
>     match y {
>       Good(foo: foo) -> {
>         ret(foo)
>       };
>       Bad(foo: foo) -> {
>         ret(foo)
>       }
>     }
>   };
> let  = %yield(0: fun (x) ret {
>   let x2 = make(0: x);
>   let x3 = use(0: x2);
>   ret(x3)
> });
> done


fn(a : ('T|'F),b : 'T|'F,c : 'T|'F) {
  match (a, b, c) {
  | (T, T, _)
  | (_, T, T)
  | (T, _, T) => true

  | (F, F, _)
  | (_, F, F)
  | (F, _, F) => false
  }
}
> fn (a: ('T | 'F), b: 'T | 'F, c: 'T | 'F) {
>   match (a, b, c) {
>     | (T, T, _)
>     | (_, T, T)
>     | (T, _, T) => true
>     | (F, F, _)
>     | (_, F, F)
>     | (F, _, F) => false
>   }
> }
>   fn (a: 'T | 'F, b: 'T | 'F, c: 'T | 'F) -> bool {
>     match (a, b, c) {
>       | (T, T, _)
>       | (_, T, T)
>       | (T, _, T) => true
>       | (F, F, _)
>       | (_, F, F)
>       | (F, _, F) => false
>     }
>   }
> ('T | 'F, 'T | 'F, 'T | 'F) -> bool
> let  = %yield(0: fun (a, b, c) ret {
>   let v0, v1, v2 = (0: a, 1: b, 2: c).(0, 1, 2);
>   match v0 {
>     T() -> {
>       match v1 {
>         T() -> {
>           match v2 {
>             T() -> {
>               ret(<true>)
>             };
>             F() -> {
>               ret(<true>)
>             }
>           }
>         };
>         F() -> {
>           match v2 {
>             T() -> {
>               ret(<true>)
>             };
>             F() -> {
>               ret(<false>)
>             }
>           }
>         }
>       }
>     };
>     F() -> {
>       match v1 {
>         T() -> {
>           match v2 {
>             T() -> {
>               ret(<true>)
>             };
>             F() -> {
>               ret(<false>)
>             }
>           }
>         };
>         F() -> {
>           match v2 {
>             F() -> {
>               ret(<false>)
>             };
>             T() -> {
>               ret(<false>)
>             }
>           }
>         }
>       }
>     }
>   }
> });
> done

fn(a : ('T|'F),b : 'T|'F,c : 'T|'F) {
  match (a, b, c) {
  | (T, T, _)
  | (T, _, T) => true

  | (_, F, F)
  | (F, _, F) => false
  }
}
> fn (a: ('T | 'F), b: 'T | 'F, c: 'T | 'F) {
>   match (a, b, c) {
>     | (T, T, _)
>     | (T, _, T) => true
>     | (_, F, F)
>     | (F, _, F) => false
>   }
> }
> test:2: Some cases of this pattern-match are missing:
>     match (a, b, c) {
>           ^^^^^^^^^
> The following cases are unhandled:
> | (F, F, T)
> | (F, T, T)

fn(x : ('A|'B|'C), y : ('A|'B|'C)) {
  match x, y {
    A, A => 1
  }
}
> fn (x: ('A | 'B | 'C), y: ('A | 'B | 'C)) { match x, y { A, A => 1 } }
> test:2: Some cases of this pattern-match are missing:
>     match x, y {
>           ^^^^
> The following cases are unhandled:
> | A, B | C
> | B | C, _

fn (x : (('A(int,int)|'B{x:string,y:string}|'C|'D|'E), 'B|'C|'D)) {
  match x {
  | (A(_,_)|B{...}, C|D)
  | (C, C)
  | (D, C) => 1
  }
}
> fn (x: (('A(int, int) | 'B{x: string, y: string} | 'C | 'D | 'E), 'B | 'C | 'D)) {
>   match x {
>     | (A(_, _) | B(...), C | D)
>     | (C, C)
>     | (D, C) => 1
>   }
> }
> test:2: Some cases of this pattern-match are missing:
>     match x {
>           ^
> The following cases are unhandled:
> | (A(_, _), B)
> | (B{x: _, y: _}, B)
> | (C, B | D)
> | (D, B | D)
> | (E, _)

fn(x : 'A(int, 'P|'Q|'R) | 'B(int, 'P|'Q|'R)) {
  match {averylongnameinanexpression: {averylongnameinanexpression: x}}.averylongnameinanexpression.averylongnameinanexpression, {x:0,y:5}.y {
  | A(x, P|Q), y => 1
  | B(x, P|Q), y => 1
  }
}
> fn (x: 'A(int, 'P | 'Q | 'R) | 'B(int, 'P | 'Q | 'R)) {
>   match
>     {averylongnameinanexpression: {averylongnameinanexpression: x}}.averylongnameinanexpression.averylongnameinanexpression,
>     {x: 0, y: 5}.y
>   {
>     | A(x, P | Q), y => 1
>     | B(x, P | Q), y => 1
>   }
> }
> test:2: Some cases of this pattern-match are missing:
>     match {averylongnameinanexpression: {averylongnameinanexpression: x}}.averylongnameinanexpression.averylongnameinanexpression, {x:0,y:5}.y {
>           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> The following cases are unhandled:
> | A(_, R), _
> | B(_, R), _

let calls_any = fn(f) {
  (f(Foo), f(Bar), f(Baz))
};
let use = fn(x) {
  match x {
  | Foo => 1
  | Bar => 2
  }
};
calls_any(use)
> let calls_any = fn (f) { (f(Foo), f(Bar), f(Baz)) };
> let use = fn (x) { match x { Foo => 1 | Bar => 2 } };
> calls_any(use)
> test:10: The tag should be Foo|Bar, but tag Baz is present.
>   calls_any(use)
>             ^^^
>      found: ('Foo | 'Bar) -> _
>   expected: ('Foo | 'Bar | 'Baz) -> _
> This 'Baz comes from test:2:
>     (f(Foo), f(Bar), f(Baz))
>                        ^^^
> but is used as 'Foo | 'Bar at test:6,test:7:
>     | Foo => 1
>       ^^^
>     | Bar => 2
>       ^^^

# codegen test for single-case matches
fn(x) {
  match x {
  | (a, b, c) =>
    let c2 = match c { y => y };
    (c2, b, a)
  }
}
> fn (x) { match x { (a, b, c) => let c2 = match c { y => y }; (c2, b, a) } }
>   fn [A, B, C](x: (A, B, C)) -> (C, B, A) {
>     match x {
>       | (a, b, c) => let c2 : C = match c { y => y }; (c2, b, a)
>     }
>   }
> [A, B, C] ((A, B, C)) -> (C, B, A)
> let  = %yield(0: fun (x) ret {
>   let v0, v1, v2 = x.(0, 1, 2);
>   ret((0: v2, 1: v1, 2: v0))
> });
> done

fn(x, y) {
  match x, y {
  | A, A => 1
  | A, B => 2
  | B, A => 3
  }
}
> fn (x, y) { match x, y { A, A => 1 | A, B => 2 | B, A => 3 } }
>   fn (x: 'A | 'B, y: 'A) -> int {
>     match x, y {
>       | A, A => 1
>       | A, B => 2
>       | B, A => 3
>     }
>   }
> ('A | 'B, 'A) -> int
> RECHECK: Failure("unknown ctor")
> 
> ELAB: Failure("unknown ctor")
> 
> ELABINF: Failure("unknown ctor")
> 
> let  = %yield(0: fun (x, y) ret {
>   match x {
>     A() -> {
>       match y {
>         A() -> {
>           ret(1)
>         };
>         B() -> {
>           ret(2)
>         }
>       }
>     };
>     B() -> {
>       match y {
>         A() -> {
>           ret(3)
>         }
>       }
>     }
>   }
> });
> done

# Compilation & errors with default cases
fn (x : 'A | 'B | 'C | 'D | 'E, y) -> int {
  match x, y {
  | A, (A | B) => 1
  | _, (A | B) => 2
  }
}
> fn (x: 'A | 'B | 'C | 'D | 'E, y) -> int {
>   match x, y {
>     | A, (A | B) => 1
>     | _, (A | B) => 2
>   }
> }
>   fn (x: 'A | 'B | 'C | 'D | 'E, y: 'A | 'B) -> int {
>     match x, y {
>       | A, (A | B) => 1
>       | _, (A | B) => 2
>     }
>   }
> ('A | 'B | 'C | 'D | 'E, 'A | 'B) -> int
> let  = %yield(0: fun (x, y) ret {
>   match x {
>     A() -> {
>       match y {
>         A() -> {
>           ret(1)
>         };
>         B() -> {
>           ret(1)
>         }
>       }
>     };
>     (B|C|D|E)() -> {
>       match y {
>         A() -> {
>           ret(2)
>         };
>         B() -> {
>           ret(2)
>         }
>       }
>     }
>   }
> });
> done

# FIXME: gets the right answer, but needs parens in printing
fn (x : 'A | 'B | 'C | 'D | 'E, y: 'A | 'B) -> int {
  match x, y {
  | A, (A | B) => 1
  | _, (A) => 2
  }
}
> fn (x: 'A | 'B | 'C | 'D | 'E, y: 'A | 'B) -> int {
>   match x, y {
>     | A, (A | B) => 1
>     | _, (A) => 2
>   }
> }
> test:2: Some cases of this pattern-match are missing:
>     match x, y {
>           ^^^^
> The following cases are unhandled:
> | B | C | D | E, B


# end
> STATS: fix: 2, flex: 159
