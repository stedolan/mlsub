# poly!
fn[A](x : A) { x }
> fn [A](x: A) { x }
> * ⊢ [A] (A) -> A
>   fn [A](x: A) : A { x }
> [A] (A) -> A

fn[A,B](id : [A](A) -> A, (x,y):(A, B)) { (id(y),id(x)) }
> fn [A, B](id: [A] (A) -> A, (x, y): (A, B)) { (id(y), id(x)) }
> * ⊢ [A, B] ([A_2] (A_2) -> A_2, (A, B)) -> (B, A)
>   fn [A, B](id: [A_2] (A_2) -> A_2, (x, y): (A, B)) : (B, A) { (id(y), id(x)) }
> [A, B] ([A_2] (A_2) -> A_2, (A, B)) -> (B, A)

fn(id : [A](A) -> A, (x,y)) { (id(y),id(x)) }
> fn (id: [A] (A) -> A, (x, y)) { (id(y), id(x)) }
> * ⊢ [A, B] ([A_2] (A_2) -> A_2, (B, A)) -> (A, B)
>   fn [A, B](id: [A_2] (A_2) -> A_2, (x, y): (B, A)) : (A, B) { (id(y), id(x)) }
> [A, B] ([A_2] (A_2) -> A_2, (B, A)) -> (A, B)

fn[A](x : A) { if x.cond {x} else {x} }
> fn [A](x: A) { if x.cond{x} else {x} }
> typechecking error: Failure("incompat")

fn[A <: {cond:bool}](x : A) { if x.cond {x} else {x} }
> fn [A <: {cond: bool}](x: A) { if x.cond{x} else {x} }
> * ⊢ [A <: {cond: bool}] (A) -> A
>   fn [A <: {cond: bool}](x: A) : A { if x.cond{x} else {x} }
> [A <: {cond: bool}] (A) -> A

fn(f) { fn[A](x : A) { f(x) } }
> fn (f) { fn [A](x: A) { f(x) } }
> * ⊢ [A] ((any) -> A) -> [A_2] (A_2) -> A
>   fn [A](f: (any) -> A) : [A_2] (A_2) -> A { fn [A_2](x: A_2) : A { f(x) } }
> [A] ((any) -> A) -> [A_2] (A_2) -> A

# partial poly
fn[A,C](a : A, b, c : C, d) { (a, b, c, d) }
> fn [A, C](a: A, b, c: C, d) { (a, b, c, d) }
> * ⊢ [A, C, B, D] (A, B, C, D) -> (A, B, C, D)
>   fn [A, C, B, D](a: A, b: B, c: C, d: D) : (A, B, C, D) { (a, b, c, d) }
> [A, C, B, D] (A, B, C, D) -> (A, B, C, D)

# bidir poly functions

(fn (x: A) { x } : [A] (A) -> A)
> (fn (x: A) { x } : [A] (A) -> A)
> typechecking error: Failure("unknown type A")

(fn (x: bool) { x } : [A] (A) -> A)
> (fn (x: bool) { x } : [A] (A) -> A)
> typechecking error: Failure("incompat")

(fn (x: any) { x } : [A] (A) -> A)
> (fn (x: any) { x } : [A] (A) -> A)
> typechecking error: Failure("incompat")

(fn[B] (x: B) { x } : [A] (A) -> A)
> (fn [B](x: B) { x } : [A] (A) -> A)
> * ⊢ [A] (A) -> A
>   (fn [B](x: B) : B { x } : [A] (A) -> A)
> [A] (A) -> A

(fn[B] (x) { (x : B) } : [A] (A) -> A)
> (fn [B](x) { (x : B) } : [A] (A) -> A)
> * ⊢ [A] (A) -> A
>   (fn [B](x: B) : B { (x : B) } : [A] (A) -> A)
> [A] (A) -> A

(fn[B] (x) : B { (x : B) } : [A] (A) -> A)
> (fn [B](x) : B { (x : B) } : [A] (A) -> A)
> * ⊢ [A] (A) -> A
>   (fn [B](x: B) : B { (x : B) } : [A] (A) -> A)
> [A] (A) -> A

fn[B <: {foo:int}] (x) : B { x }
> fn [B <: {foo: int}](x) : B { x }
> * ⊢ [B <: {foo: int}] (B) -> B
>   fn [B <: {foo: int}](x: B) : B { x }
> [B <: {foo: int}] (B) -> B

fn[B <: {foo:int}] (x) { (x : B) }
> fn [B <: {foo: int}](x) { (x : B) }
> * ⊢ [B <: {foo: int}] (B) -> B
>   fn [B <: {foo: int}](x: B) : B { (x : B) }
> [B <: {foo: int}] (B) -> B

(fn() { @true } : [A]() -> bool)
> (fn () { @true } : [A] () -> bool)
> typechecking error: Failure("pragma: true")

# FIXME
# fn[A,B](x:A, y:B) { if true { x } else { y } }
# > fn [A, B](x: A, y: B) { if true{x} else {y} }
# > File "src/check.ml", line 22, characters 2-8: Assertion failed
# > Raised at Lang__Check.env_gen_var in file "src/check.ml", line 22, characters 2-34
# > Called from Lang__Typedefs.map_free_typ in file "src/typedefs.ml", line 332, characters 25-56
# > Called from Lang__Typedefs.map_head in file "src/typedefs.ml", line 240, characters 46-55
# > Called from Lang__Typedefs.map_free_typ in file "src/typedefs.ml", line 333, characters 24-68
# > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 43, characters 15-43
# > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
# > Called from Lang__Check.elab_poly in file "src/check.ml", line 226, characters 14-72
# > Called from Lang__Check.infer' in file "src/check.ml", line 352, characters 7-803
# > Called from Lang__Check.infer in file "src/check.ml", line 307, characters 17-29
# > Called from Lang__Check.elab_gen in file "src/check.ml", line 190, characters 29-36
# > Called from Dune__exe__Test_runner.run_cmd in file "test/test_runner.ml", line 54, characters 17-70

fn[A,B](x : A, y : B) : A|B { if true { x } else { y } }
> fn [A, B](x: A, y: B) : A | B { if true{x} else {y} }
> * ⊢ [A, B] (A, B) -> A | B
>   fn [A, B](x: A, y: B) : A | B { if true{x} else {y} }
> [A, B] (A, B) -> A | B

let ch = fn[A,B](x : A, y : B) : A|B { if true { x } else { y } }; ch
> let ch = fn [A, B](x: A, y: B) : A | B { if true{x} else {y} }; ch
> * ⊢ [A, B] (A, B) -> A | B
>   let ch : [A, B] (A, B) ->
>   A |
>   B =
>   fn [A, B](x: A, y: B) : A | B { if true{x} else {y} };
>   ch
> [A, B] (A, B) -> A | B

let ch = fn[A,B](x : A, y : B) : A|B { if true { x } else { y } }; fn (a,b) { ch(a, b) }
> let ch = fn [A, B](x: A, y: B) : A | B { if true{x} else {y} }; fn (a, b) { ch(a, b) }
> * ⊢ [A, B] (A, B) -> A | B
>   let ch : [A, B] (A, B) ->
>   A |
>   B =
>   fn [A, B](x: A, y: B) : A | B { if true{x} else {y} };
>   fn [A, B](a: A, b: B) : A |
>   B { ch(a, b) }
> [A, B] (A, B) -> A | B

(fn[A,B](x : A, y : B) : A|B { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B](x: A, y: B) : A | B { if true{x} else {y} } : [A] (A, A) -> A)
> * ⊢ [A] (A, A) -> A
>   (fn [A, B](x: A, y: B) : A | B { if true{x} else {y} } : [A] (A, A) -> A)
> [A] (A, A) -> A

(fn[A,B,R, A<:R, B<:R](x : A, y : B) : R { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B, R, A <: R, B <: R](x: A, y: B) : R { if true{x} else {y} } : [A] (A, A) -> A)
> * ⊢ ∀⁺ 0:[⊥,⊤]. (.0.0, .0.0) → .0.0
>   (fn [A, B, R, B <: R, A <: R](x: A, y: B) : R { if true{x} else {y} } : [A] (A,
>   A) ->
>   A)
> [A] (A, A) -> A

(fn[A,B,R, A<:R](x : A, y : B) : R { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B, R, A <: R](x: A, y: B) : R { if true{x} else {y} } : [A] (A, A) -> A)
> typechecking error: Failure("incompat")

(fn[A,B,R](x : A, y : B) : R|A { x } : [A] (A, A) -> A)
> (fn [A, B, R](x: A, y: B) : R | A { x } : [A] (A, A) -> A)
> * ⊢ [A] (A, A) -> A
>   (fn [A, B, R](x: A, y: B) : R | A { x } : [A] (A, A) -> A)
> [A] (A, A) -> A

# debugging

# FIXME
#FIXME 
#FIXME let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { wid(fn(x){let () = f(x); x.foo}) }
#FIXME > let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) }; fn (f) { wid(fn (x) { let () = f(x); x.foo }) }
#FIXME > File "src/typedefs.ml", line 558, characters 19-25: Assertion failed
#FIXME > Raised at Lang__Typedefs.wf_styp_gen in file "src/typedefs.ml", line 558, characters 19-31
#FIXME > Called from Stdlib__map.Make.iter in file "map.ml", line 296, characters 20-25
#FIXME > Called from Lang__Type_simplification.remove_joins.canon_var in file "src/type_simplification.ml", line 65, characters 4-24
#FIXME > Called from Lang__Typedefs.map_free_typ in file "src/typedefs.ml", line 332, characters 25-56
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 43, characters 15-43
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 40, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 51, characters 16-48
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 40, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 40, characters 11-40
#FIXME > Called from Lang__Type_simplification.remove_joins in file "src/type_simplification.ml", line 98, characters 11-47
#FIXME > Called from Lang__Check.elab_gen in file "src/check.ml", line 194, characters 15-62
#FIXME > Re-raised at Lang__Check.elab_gen in file "src/check.ml", line 195, characters 120-127
#FIXME > Called from Lang__Check.elab_poly in file "src/check.ml", line 217, characters 20-26
#FIXME > Called from Lang__Check.infer' in file "src/check.ml", line 352, characters 7-803
#FIXME > Called from Lang__Check.infer in file "src/check.ml", line 307, characters 17-29
#FIXME > Called from Lang__Check.infer' in file "src/check.ml", line 346, characters 21-35
#FIXME > Called from Lang__Check.infer in file "src/check.ml", line 307, characters 17-29
#FIXME > Called from Lang__Check.elab_gen in file "src/check.ml", line 190, characters 29-36
#FIXME > Called from Dune__exe__Test_runner.run_cmd in file "test/test_runner.ml", line 54, characters 17-70
#FIXME 
#FIXME let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f) { wid(fn(x){let z = f({bar:x}); x.foo}) }
#FIXME > let wid = fn (id: [B, A <: {foo: B}] (A) -> B) { id({foo: 5}) }; fn (f) { wid(fn (x) { let z = f({bar: x}); x.foo }) }
#FIXME > File "src/typedefs.ml", line 558, characters 19-25: Assertion failed
#FIXME > Raised at Lang__Typedefs.wf_styp_gen in file "src/typedefs.ml", line 558, characters 19-31
#FIXME > Called from Stdlib__map.Make.iter in file "map.ml", line 296, characters 20-25
#FIXME > Called from Lang__Type_simplification.remove_joins.canon_var in file "src/type_simplification.ml", line 65, characters 4-24
#FIXME > Called from Lang__Typedefs.map_free_typ in file "src/typedefs.ml", line 332, characters 25-56
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 43, characters 15-43
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 40, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 51, characters 16-48
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 40, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 41, characters 11-40
#FIXME > Called from Lang__Elab.map_free_elab_req in file "src/elab.ml", line 40, characters 11-40
#FIXME > Called from Lang__Type_simplification.remove_joins in file "src/type_simplification.ml", line 98, characters 11-47
#FIXME > Called from Lang__Check.elab_gen in file "src/check.ml", line 194, characters 15-62
#FIXME > Re-raised at Lang__Check.elab_gen in file "src/check.ml", line 195, characters 120-127
#FIXME > Called from Lang__Check.elab_poly in file "src/check.ml", line 217, characters 20-26
#FIXME > Called from Lang__Check.infer' in file "src/check.ml", line 352, characters 7-803
#FIXME > Called from Lang__Check.infer in file "src/check.ml", line 307, characters 17-29
#FIXME > Called from Lang__Check.infer' in file "src/check.ml", line 346, characters 21-35
#FIXME > Called from Lang__Check.infer in file "src/check.ml", line 307, characters 17-29
#FIXME > Called from Lang__Check.elab_gen in file "src/check.ml", line 190, characters 29-36
#FIXME > Called from Dune__exe__Test_runner.run_cmd in file "test/test_runner.ml", line 54, characters 17-70
#FIXME 

let id = fn(x) { x }; fn () { (id (id), id) }
> let id = fn (x) { x }; fn () { (id(id), id) }
> * ⊢ [A] () -> ((A) -> A, [A_2] (A_2) -> A_2)
>   let id : [A] (A) -> A = fn [A](x: A) : A { x };
>   fn [A]() : ((A) -> A, [A_2] (A_2) -> A_2) { (id(id), id) }
> [A] () -> ((A) -> A, [A_2] (A_2) -> A_2)


fn(f) { fn(id: [A] (A) -> A) { let x = f(id); id(1) } }
> fn (f) { fn (id: [A] (A) -> A) { let x = f(id); id(1) } }
> * ⊢ [A, B] (((B) -> B) -> A) -> ([A_2] (A_2) -> A_2) -> int
>   fn [A, B](f: ((B) -> B) -> A) : ([A_2] (A_2) -> A_2) ->
>   int { fn (id: [A_2] (A_2) -> A_2) : int { let x : A = f(id); id(1) } }
> [A, B] (((B) -> B) -> A) -> ([A_2] (A_2) -> A_2) -> int

fn(f) { fn(id: [A] (A) -> A) { id(fn(y) { let x = f(y); y }) } }
> fn (f) { fn (id: [A] (A) -> A) { id(fn (y) { let x = f(y); y }) } }
> * ⊢ [A, B] ((A) -> B) -> ([A_2] (A_2) -> A_2) -> (A) -> A
>   fn [A, B](f: (A) -> B) : ([A_2] (A_2) -> A_2) ->
>   (A) ->
>   A {
>   fn (id: [A_2] (A_2) -> A_2) : (A) ->
>   A { id(fn (y: A) : A { let x : B = f(y); y }) }
>   }
> [A, B] ((A) -> B) -> ([A_2] (A_2) -> A_2) -> (A) -> A


(fn(x) {(fn(y){y})(x)} : [A] (A) -> A)
> (fn (x) { (fn (y) { y })(x) } : [A] (A) -> A)
> * ⊢ [A] (A) -> A
>   (fn [A](x: A) : A { (fn [A_2](y: A_2) : A_2 { y })(x) } : [A] (A) -> A)
> [A] (A) -> A

let id = fn(y) { y }; (fn[A](x : A) {id(x)})
> let id = fn (y) { y }; (fn [A](x: A) { id(x) })
> * ⊢ [A] (A) -> A
>   let id : [A] (A) -> A = fn [A](y: A) : A { y }; (fn [A](x: A) : A { id(x) })
> [A] (A) -> A

let id = fn(y) { y }; (fn(x) {id(x)} : [A] (A) -> A)
> let id = fn (y) { y }; (fn (x) { id(x) } : [A] (A) -> A)
> * ⊢ [A] (A) -> A
>   let id : [A] (A) -> A = fn [A](y: A) : A { y };
>   (fn [A](x: A) : A { id(x) } : [A] (A) -> A)
> [A] (A) -> A


fn[A,B](x : [X <: B](X|A) -> X) : (A) -> B { x }
> fn [A, B](x: [X <: B] (X | A) -> X) : (A) -> B { x }
> typechecking error: Failure("rig var bounds must be Tcons")

fn[A,B](x : [X <: B](X|A) -> X) : (A) -> A|B { x }
> fn [A, B](x: [X <: B] (X | A) -> X) : (A) -> A | B { x }
> typechecking error: Failure("rig var bounds must be Tcons")

# wtf:
# fn[A,B,A <: B](x : [X, X <: A, X :> B](X) -> X) : [X <: A, Y :> B, X <: Y](X) -> Y { x }
# > parser failure: bad parse
