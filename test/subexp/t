# poly!
fn[A](x : A) { x }
> fn [A](x: A) { x }
>   fn [A](x: A) -> A { x }
> [A] (A) -> A

fn[A,B](id : [A](A) -> A, (x,y):(A, B)) { (id(y),id(x)) }
> fn [A, B](id: [A] (A) -> A, (x, y): (A, B)) { (id(y), id(x)) }
>   fn [A, B](id: [A_2] (A_2) -> A_2, (x, y): (A, B)) -> (B, A) { (id(y), id(x)) }
> [A, B] ([A_2] (A_2) -> A_2, (A, B)) -> (B, A)

fn(id : [A](A) -> A, (x,y)) { (id(y),id(x)) }
> fn (id: [A] (A) -> A, (x, y)) { (id(y), id(x)) }
>   fn [A, B](id: [A_2] (A_2) -> A_2, (x, y): (A, B)) -> (B, A) { (id(y), id(x)) }
> [A, B] ([A_2] (A_2) -> A_2, (A, B)) -> (B, A)

fn[A](x : A) { if x.cond {x} else {x} }
> fn [A](x: A) { if x.cond { x } else { x } }
> test:1: Type error
>   fn[A](x : A) { if x.cond {x} else {x} }
>                     ^
>      found: A
>   expected: {cond: _, ...}
> This A comes from test:1:
>   fn[A](x : A) { if x.cond {x} else {x} }
>             ^
> but is used as {cond: _, ...} at test:1:
>   fn[A](x : A) { if x.cond {x} else {x} }
>                     ^^^^^^

fn[A <: {cond:bool}](x : A) { if x.cond {x} else {x} }
> fn [A <: {cond: bool}](x: A) { if x.cond { x } else { x } }
>   fn [A <: {cond: bool}](x: A) -> A { if x.cond { x } else { x } }
> [A <: {cond: bool}] (A) -> A

fn(f) { fn[A](x : A) { f(x) } }
> fn (f) { fn [A](x: A) { f(x) } }
>   fn [A](f: (any) -> A) -> [A_2] (A_2) -> A { fn [A_2](x: A_2) -> A { f(x) } }
> [A] ((any) -> A) -> [A_2] (A_2) -> A

fn[A,B <: A](x : A) -> B { x }
> fn [A, B <: A](x: A) -> B { x }
> test:1: Bounds must be constructed types

fn[A,B <: A](x : B) -> A { x }
> fn [A, B <: A](x: B) -> A { x }
> test:1: Bounds must be constructed types

# contravariant join checks
fn[A,B](x : A|B) -> A|B {x}
> fn [A, B](x: A | B) -> A | B { x }
> typechecking error: Failure("contravariant join")

fn[A,B](x : (A|B) -> A) { fn(a){x(a)} }
> fn [A, B](x: (A | B) -> A) { fn (a) { x(a) } }
>   fn [A, B](x: (A | B) -> A) -> (A | B) -> A { fn (a: A | B) -> A { x(a) } }
> [A, B] ((A | B) -> A) -> (A | B) -> A
> RECHECK: Failure("contravariant join")
> 
> ELAB: Failure("contravariant join")
> 
> ELABINF: Failure("contravariant join")

fn[A,B](x) -> (A|B) -> A {x}
> fn [A, B](x) -> (A | B) -> A { x }
> typechecking error: Failure("contravariant join")

fn[A,B](x) -> A|B {x}
> fn [A, B](x) -> A | B { x }
>   fn [A, B](x: A | B) -> A | B { x }
> [A, B] (A | B) -> A | B
> RECHECK: Failure("contravariant join")
> 
> ELAB: Failure("contravariant join")
> 
> ELABINF: Failure("contravariant join")

fn[A,B](f : (A|B) -> A, x: B) -> ((A|B) -> A, B) { (f,x) }
> fn [A, B](f: (A | B) -> A, x: B) -> ((A | B) -> A, B) { (f, x) }
> typechecking error: Failure("contravariant join")

fn (f,x) { (fn(f, x) { let y = f(f(x)); (f, x) })(f,x) }
> fn (f, x) { (fn (f, x) { let y = f(f(x)); (f, x) })(f, x) }
>   fn [A, B, C <: (A | B) -> A](f: C, x: B) -> (C, B) {
>     (fn [A_2, B_2, C_2 <: (A_2 | B_2) -> A_2](f: C_2, x: B_2) -> (C_2, B_2) {
>       let y : A_2 = f(f(x));
>       (f, x)
>     })(f, x)
>   }
> [A, B, C <: (A | B) -> A] (C, B) -> (C, B)

fn[P,Q,R](f : (P|Q|R) -> P, x : Q) -> (((R) -> (P|R)), Q) { (f, x) }
> fn [P, Q, R](f: (P | Q | R) -> P, x: Q) -> (((R) -> (P | R)), Q) { (f, x) }
>   fn [P, Q, R](f: (P | Q | R) -> P, x: Q) -> ((R) -> P | R, Q) { (f, x) }
> [P, Q, R] ((P | Q | R) -> P, Q) -> ((R) -> P | R, Q)

fn (f,x) { (fn(f, x) { let y = f(f(x)); (fn(p){f(p)}, x) })(f,x) }


> fn (f, x) { (fn (f, x) { let y = f(f(x)); (fn (p) { f(p) }, x) })(f, x) }
>   fn [A, B, C](f: (A | B | C) -> B, x: C) -> ((A) -> B, C) {
>     (fn [A_2, B_2, C_2](f: (A_2 | B_2 | C_2) -> B_2, x: C_2) ->
>       ((A_2) -> B_2, C_2) {
>       let y : B_2 = f(f(x));
>       (fn (p: A_2) -> B_2 { f(p) }, x)
>     })(f, x)
>   }
> [A, B, C] ((A | B | C) -> B, C) -> ((A) -> B, C)
# partial poly
fn[A,C](a : A, b, c : C, d) { (a, b, c, d) }
> fn [A, C](a: A, b, c: C, d) { (a, b, c, d) }
>   fn [A, C, B, D](a: A, b: B, c: C, d: D) -> (A, B, C, D) { (a, b, c, d) }
> [A, C, B, D] (A, B, C, D) -> (A, B, C, D)

# real rank1 type (check forall not hoisted)
fn (a) { (fn(x) { (x, fn(x) { x }) })(a) }
> fn (a) { (fn (x) { (x, fn (x) { x }) })(a) }
>   fn [A](a: A) -> (A, [A_2] (A_2) -> A_2) {
>     (fn [A_2](x: A_2) -> (A_2, [A_3] (A_3) -> A_3) {
>       (x, fn [A_3](x: A_3) -> A_3 { x })
>     })(a)
>   }
> [A] (A) -> (A, [A_2] (A_2) -> A_2)

# bidir poly functions

(fn (x: A) { x } : [A] (A) -> A)
> (fn (x: A) { x } : [A] (A) -> A)
> test:1: Unknown type name: A

(fn (x: bool) { x } : [A] (A) -> A)
> (fn (x: bool) { x } : [A] (A) -> A)
> test:1: Type error
>   (fn (x: bool) { x } : [A] (A) -> A)
>           ^^^^
>      found: A
>   expected: bool
> This A comes from test:1:
>   (fn (x: bool) { x } : [A] (A) -> A)
>                              ^
> but is used as bool

(fn (x: any) { x } : [A] (A) -> A)
> (fn (x: any) { x } : [A] (A) -> A)
> test:1: Type error
>   (fn (x: any) { x } : [A] (A) -> A)
>                  ^
>      found: any
>   expected: A
> This any comes from test:1:
>   (fn (x: any) { x } : [A] (A) -> A)
>           ^^^
> but is used as A at test:1:
>   (fn (x: any) { x } : [A] (A) -> A)
>                                   ^

(fn[B] (x: B) { x } : [A] (A) -> A)
> (fn [B](x: B) { x } : [A] (A) -> A)
>   (fn [B](x: B) -> B { x } : [A] (A) -> A)
> [A] (A) -> A

(fn[B] (x) { (x : B) } : [A] (A) -> A)
> (fn [B](x) { (x : B) } : [A] (A) -> A)
>   (fn [B](x: B) -> B { (x : B) } : [A] (A) -> A)
> [A] (A) -> A

(fn[B] (x) -> B { (x : B) } : [A] (A) -> A)
> (fn [B](x) -> B { (x : B) } : [A] (A) -> A)
>   (fn [B](x: B) -> B { (x : B) } : [A] (A) -> A)
> [A] (A) -> A

fn[B <: {foo:int}] (x) -> B { x }
> fn [B <: {foo: int}](x) -> B { x }
>   fn [B <: {foo: int}](x: B) -> B { x }
> [B <: {foo: int}] (B) -> B

fn[B <: {foo:int}] (x) { (x : B) }
> fn [B <: {foo: int}](x) { (x : B) }
>   fn [B <: {foo: int}](x: B) -> B { (x : B) }
> [B <: {foo: int}] (B) -> B

(fn() { @true } : [A]() -> bool)
> (fn () { @true } : [A] () -> bool)
>   (fn () { @true } : [A] () -> bool)
> [A] () -> bool

fn(id, x) { (id(x), id(5)) }
> fn (id, x) { (id(x), id(5)) }
>   fn [A, B](id: (int | A) -> B, x: A) -> (B, B) { (id(x), id(5)) }
> [A, B] ((int | A) -> B, A) -> (B, B)

(fn(id, x) { (id(x), id(5)) } : [A]([B](B) -> B, A) -> (A,int))
> (fn (id, x) { (id(x), id(5)) } : [A] ([B] (B) -> B, A) -> (A, int))
>   (fn (id, x) { (id(x), id(5)) } : [A] ([B] (B) -> B, A) -> (A, int))
> [A] ([B] (B) -> B, A) -> (A, int)

fn[A,B](x:A, y:B) { if true { x } else { y } }
> fn [A, B](x: A, y: B) { if true { x } else { y } }
>   fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } }
> [A, B] (A, B) -> A | B

fn[A,B](x : A, y : B) -> A|B { if true { x } else { y } }
> fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } }
>   fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } }
> [A, B] (A, B) -> A | B

let ch = fn[A,B](x : A, y : B) -> A|B { if true { x } else { y } }; ch
> let ch = fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } }; ch
>   let ch : [A, B] (A, B) -> A | B =
>   fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } };
>   ch
> [A, B] (A, B) -> A | B

let ch = fn[A,B](x : A, y : B) -> A|B { if true { x } else { y } }; fn (a,b) { ch(a, b) }
> let ch = fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } };
> fn (a, b) {
>   ch(a, b)
> }
>   let ch : [A, B] (A, B) -> A | B =
>   fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } };
>   fn [A, B](a: A, b: B) -> A | B {
>     ch(a, b)
>   }
> [A, B] (A, B) -> A | B

(fn[A,B](x : A, y : B) -> A|B { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } } : [A] (A, A) -> A)
>   (fn [A, B](x: A, y: B) -> A | B { if true { x } else { y } } : [A] (A, A) -> A)
> [A] (A, A) -> A

(fn[A,B,R](x : A, y : B) -> A|B|R { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B, R](x: A, y: B) -> A | B | R {
>   if true {
>     x
>   } else {
>     y
>   }
> } : [A] (A, A) -> A)
>   (fn [A, B, R](x: A, y: B) -> A | B | R {
>     if true {
>       x
>     } else {
>       y
>     }
>   } : [A] (A, A) -> A)
> [A] (A, A) -> A

(fn[A,B,R](x : A, y : B) -> R|A { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B, R](x: A, y: B) -> R | A {
>   if true {
>     x
>   } else {
>     y
>   }
> } : [A] (A, A) -> A)
> test:1: Type error
>   (fn[A,B,R](x : A, y : B) -> R|A { if true { x } else { y } } : [A] (A, A) -> A)
>                                                          ^
>      found: B
>   expected: R | A
> This B comes from test:1:
>   (fn[A,B,R](x : A, y : B) -> R|A { if true { x } else { y } } : [A] (A, A) -> A)
>                         ^
> but is used as R | A at test:1:
>   (fn[A,B,R](x : A, y : B) -> R|A { if true { x } else { y } } : [A] (A, A) -> A)
>                               ^

(fn[A,B,R](x : A, y : B) -> R|A { x } : [A] (A, A) -> A)
> (fn [A, B, R](x: A, y: B) -> R | A { x } : [A] (A, A) -> A)
>   (fn [A, B, R](x: A, y: B) -> R | A { x } : [A] (A, A) -> A)
> [A] (A, A) -> A

# debugging

let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { wid(fn(x){f(5); x.foo}) }
> let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) };
> fn (f) {
>   wid(fn (x) { f(5); x.foo })
> }
>   let wid : ([B] ({foo: B}) -> B) -> int =
>   fn (id: [B] ({foo: B}) -> B) -> int { id({foo: 5}) };
>   fn (f: (int) -> ()) -> int {
>     wid(fn (x) { f(5); x.foo })
>   }
> ((int) -> ()) -> int


# making this work requires an annotation on f, due to hoisting
# (by design, but a bit weird)
# FIXME: the error message is awful
let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){f(x); x.foo}); wid(g) }
> let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) };
> fn (f) {
>   let g = (fn (x) { f(x); x.foo });
>   wid(g)
> }
> test:1: Type error
>   let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){f(x); x.foo}); wid(g) }
>                                                                                                   ^
>      found: (_) -> any
>   expected: (_) -> nothing
> This any comes from test:1:
>   let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){f(x); x.foo}); wid(g) }
>                              ^
> but is used as nothing at test:1:
>   let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){f(x); x.foo}); wid(g) }
>                                     ^

# works in checking mode (bidir)
let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { wid(fn(x){f(x); x.foo}) }
> let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) };
> fn (f) {
>   wid(fn (x) { f(x); x.foo })
> }
>   let wid : ([B] ({foo: B}) -> B) -> int =
>   fn (id: [B] ({foo: B}) -> B) -> int { id({foo: 5}) };
>   fn (f: ({foo: any}) -> ()) -> int {
>     wid(fn (x) { f(x); x.foo })
>   }
> (({foo: any}) -> ()) -> int

let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f : (any) -> ()) { wid(fn(x){f(x); x.foo}) }
> let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) };
> fn (f: (any) -> ()) {
>   wid(fn (x) { f(x); x.foo })
> }
>   let wid : ([B] ({foo: B}) -> B) -> int =
>   fn (id: [B] ({foo: B}) -> B) -> int { id({foo: 5}) };
>   fn (f: (any) -> ()) -> int {
>     wid(fn (x) { f(x); x.foo })
>   }
> ((any) -> ()) -> int


let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){let z = f({bar:x}); x.foo}); wid(g) }
> let wid = fn (id: [B, A <: {foo: B}] (A) -> B) { id({foo: 5}) };
> fn (f) {
>   let g = (fn (x) { let z = f({bar: x}); x.foo });
>   wid(g)
> }
> test:1: Type error
>   let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){let z = f({bar:x}); x.foo}); wid(g) }
>                                                                                                                        ^
>      found: (_) -> any
>   expected: (_) -> nothing
> This any comes from test:1:
>   let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){let z = f({bar:x}); x.foo}); wid(g) }
>                                  ^
> but is used as nothing at test:1:
>   let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){let z = f({bar:x}); x.foo}); wid(g) }
>                                            ^

let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f) { wid(fn(x){let z = f({bar:x}); x.foo}) }
> let wid = fn (id: [B, A <: {foo: B}] (A) -> B) { id({foo: 5}) };
> fn (f) {
>   wid(fn (x) { let z = f({bar: x}); x.foo })
> }
>   let wid : ([B, A <: {foo: B}] (A) -> B) -> int =
>   fn (id: [B, A <: {foo: B}] (A) -> B) -> int { id({foo: 5}) };
>   fn [A](f: ({bar: {foo: any}}) -> A) -> int {
>     wid(fn (x) { let z : A = f({bar: x}); x.foo })
>   }
> [A] (({bar: {foo: any}}) -> A) -> int

let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f : (any) -> string) { wid(fn(x){let z = f({bar:x}); x.foo}) }
> let wid = fn (id: [B, A <: {foo: B}] (A) -> B) { id({foo: 5}) };
> fn (f: (any) -> string) {
>   wid(fn (x) { let z = f({bar: x}); x.foo })
> }
>   let wid : ([B, A <: {foo: B}] (A) -> B) -> int =
>   fn (id: [B, A <: {foo: B}] (A) -> B) -> int { id({foo: 5}) };
>   fn (f: (any) -> string) -> int {
>     wid(fn (x) { let z : string = f({bar: x}); x.foo })
>   }
> ((any) -> string) -> int

let id = fn(x) { x }; fn () { (id (id), id) }
> let id = fn (x) { x }; fn () { (id(id), id) }
>   let id : [A] (A) -> A = fn [A](x: A) -> A { x };
>   fn [A]() -> ((A) -> A, [A_2] (A_2) -> A_2) {
>     (id(id), id)
>   }
> [A] () -> ((A) -> A, [A_2] (A_2) -> A_2)


fn(f) { fn(id: [A] (A) -> A) { let x = f(id); id(1) } }
> fn (f) { fn (id: [A] (A) -> A) { let x = f(id); id(1) } }
>   fn [A, B](f: ((A) -> A) -> B) -> ([A_2] (A_2) -> A_2) -> int {
>     fn (id: [A_2] (A_2) -> A_2) -> int {
>       let x : B = f(id);
>       id(1)
>     }
>   }
> [A, B] (((A) -> A) -> B) -> ([A_2] (A_2) -> A_2) -> int

fn(f) { fn(id: [A] (A) -> A) { id(fn(y) { let x = f(y); y }) } }
> fn (f) { fn (id: [A] (A) -> A) { id(fn (y) { let x = f(y); y }) } }
>   fn [A, B](f: (A) -> B) -> ([A_2] (A_2) -> A_2) -> (A) -> A {
>     fn (id: [A_2] (A_2) -> A_2) -> (A) -> A {
>       id(fn (y: A) -> A { let x : B = f(y); y })
>     }
>   }
> [A, B] ((A) -> B) -> ([A_2] (A_2) -> A_2) -> (A) -> A


(fn(x) {(fn(y){y})(x)} : [A] (A) -> A)
> (fn (x) { (fn (y) { y })(x) } : [A] (A) -> A)
>   (fn (x) { (fn [A](y: A) -> A { y })(x) } : [A] (A) -> A)
> [A] (A) -> A

let id = fn(y) { y }; (fn[A](x : A) {id(x)})
> let id = fn (y) { y }; (fn [A](x: A) { id(x) })
>   let id : [A] (A) -> A = fn [A](y: A) -> A { y }; (fn [A](x: A) -> A { id(x) })
> [A] (A) -> A

let id = fn(y) { y }; (fn(x) {id(x)} : [A] (A) -> A)
> let id = fn (y) { y }; (fn (x) { id(x) } : [A] (A) -> A)
>   let id : [A] (A) -> A = fn [A](y: A) -> A { y };
>   (fn (x) { id(x) } : [A] (A) -> A)
> [A] (A) -> A


fn[A,B](x : [X <: B](X|A) -> X) -> (A) -> B { x }
> fn [A, B](x: [X <: B] (X | A) -> X) -> (A) -> B { x }
> test:1: Bounds must be constructed types

fn[A,B](x : [X <: B](X|A) -> X) -> (A) -> A|B { x }
> fn [A, B](x: [X <: B] (X | A) -> X) -> (A) -> A | B { x }
> test:1: Bounds must be constructed types

# wtf:
# fn[A,B,A <: B](x : [X, X <: A, X :> B](X) -> X) -> [X <: A, Y :> B, X <: Y](X) -> Y { x }
# > parser failure: bad parse


# some invalid types that should be rejected because of bad joins
# FIXME: delete these tests? it's fine now
(@bot : [A] [B] ({foo: B} | A))
> (@bot : [A] [B] ({foo: B} | A))
>   (@bot : [A] [B] ({foo: B} | A))
> [A] [B] {foo: B} | A

(@bot : [A, B] (int, [C] ({foo: int | C} | B)))
> (@bot : [A, B] (int, [C] ({foo: int | C} | B)))
>   (@bot : [A, B] (int, [C] ({foo: int | C} | B)))
> [A, B] (int, [C] {foo: int | C} | B)

(@bot : [A <: [B]int]int)
> (@bot : [A <: [B] int] int)
> test:1: Bounds must be constructed types

(@bot : [A, B] ({foo : A} | {foo : B}))
> (@bot : [A, B] ({foo: A} | {foo: B}))
> test:1: Joins may only contain one non-variable type

# bug in substn_ntyp
fn[A](id: [B](A) -> int) { id }
> fn [A](id: [B] (A) -> int) { id }
>   fn [A](id: [B] (A) -> int) -> [B] (A) -> int { id }
> [A] ([B] (A) -> int) -> [B] (A) -> int

fn[A](id: [B](A, B) -> int, x:A) -> int {id(x,1)}
> fn [A](id: [B] (A, B) -> int, x: A) -> int { id(x, 1) }
>   fn [A](id: [B] (A, B) -> int, x: A) -> int { id(x, 1) }
> [A] ([B] (A, B) -> int, A) -> int

# If this fails someday due to unannoted x/ret, that's fine
fn[A](id: [B](A, B) -> (A, B), x){id(x,1)}
> fn [A](id: [B] (A, B) -> (A, B), x) { id(x, 1) }
>   fn [A](id: [B] (A, B) -> (A, B), x: A) -> (A, int) { id(x, 1) }
> [A] ([B] (A, B) -> (A, B), A) -> (A, int)

(fn[A](id: (A) -> (nothing)){id})(fn(a){a})
> (fn [A](id: (A) -> (nothing)) { id })(fn (a) { a })
>   (fn [A](id: (A) -> nothing) -> (A) -> nothing { id })(fn (a) { a })
> (nothing) -> nothing

# another bug
let f = fn[A](id: (A) -> A){1}; f(fn(a){a})
> let f = fn [A](id: (A) -> A) { 1 }; f(fn (a) { a })
>   let f : [A] ((A) -> A) -> int = fn [A](id: (A) -> A) -> int { 1 };
>   f(fn (a) { a })
> int

let f = fn[A](id: [B](A, B) -> (A, B), x:A){id(x,1)}; fn(z){ f(fn(a,b){(a,b)}, if z.cond {z.a}else{z.b}) }
> let f = fn [A](id: [B] (A, B) -> (A, B), x: A) { id(x, 1) };
> fn (z) {
>   f(fn (a, b) { (a, b) }, if z.cond { z.a } else { z.b })
> }
>   let f : [A] ([B] (A, B) -> (A, B), A) -> (A, int) =
>   fn [A](id: [B] (A, B) -> (A, B), x: A) -> (A, int) { id(x, 1) };
>   fn [A](z: {cond: bool, a: A, b: A, ...}) -> (A, int) {
>     f(fn (a, b) { (a, b) }, if z.cond { z.a } else { z.b })
>   }
> [A] ({cond: bool, a: A, b: A, ...}) -> (A, int)

# test match_simple_typ with complex upper bound
let appf = fn[B, C, A <: (B) -> C](f : A, x : B) { f(x) }; fn() { appf(fn(x) { x }, 1) }
> let appf = fn [B, C, A <: (B) -> C](f: A, x: B) { f(x) };
> fn () {
>   appf(fn (x) { x }, 1)
> }
>   let appf : [B, C, A <: (B) -> C] (A, B) -> C =
>   fn [B, C, A <: (B) -> C](f: A, x: B) -> C { f(x) };
>   fn () -> int {
>     appf(fn [A](x: A) -> A { x }, 1)
>   }
> () -> int

let appf = fn[B, C, A <: (B) -> C](f : A, x : B) { f(x) }; fn() { appf(fn(x) { 1 }, 1) }
> let appf = fn [B, C, A <: (B) -> C](f: A, x: B) { f(x) };
> fn () {
>   appf(fn (x) { 1 }, 1)
> }
>   let appf : [B, C, A <: (B) -> C] (A, B) -> C =
>   fn [B, C, A <: (B) -> C](f: A, x: B) -> C { f(x) };
>   fn () -> int {
>     appf(fn (x: any) -> int { 1 }, 1)
>   }
> () -> int

let appf = fn[B, C, A <: (B) -> C](f : A, x : B) { f(x) }; fn() { appf(3, 1) }
> let appf = fn [B, C, A <: (B) -> C](f: A, x: B) { f(x) }; fn () { appf(3, 1) }
> test:1: Type error
>   let appf = fn[B, C, A <: (B) -> C](f : A, x : B) { f(x) }; fn() { appf(3, 1) }
>                                                                          ^
>      found: int
>   expected: (_) -> _
> This int is used as (_) -> _ at test:1:
>   let appf = fn[B, C, A <: (B) -> C](f : A, x : B) { f(x) }; fn() { appf(3, 1) }
>                            ^^^^^^^^

# approx_ntyp
fn[P, Q <: {foo:P}] (x) -> [A, B <: {bar: Q}, C <: {x:B, y:Q}] (A, B, C) -> (A, B|(P,Q), C) { x }
> fn [P, Q <: {foo: P}](x) ->
>   [A, B <: {bar: Q}, C <: {x: B, y: Q}] (A, B, C) -> (A, B | (P, Q), C) {
>   x
> }
>   fn [P, Q <: {foo: P}](
>     x: (any, {bar: Q}, {x: {bar: Q}, y: Q}) -> (nothing, (P, Q), nothing)
>   ) -> [A, B <: {bar: Q}, C <: {x: B, y: Q}] (A, B, C) -> (A, (P, Q) | B, C) {
>     x
>   }
> [P, Q <: {foo: P}] ((any, {bar: Q}, {x: {bar: Q}, y: Q}) -> (nothing, (P, Q), nothing)) ->
> [A, B <: {bar: Q}, C <: {x: B, y: Q}] (A, B, C) -> (A, (P, Q) | B, C)

# more approx_ntyp
let f = fn (f: [B <: {foo:int,...}, A <: {bar:B}](A) -> A|B, g) { g(f) }; fn() { (fn(x){x})(f) }
> let f = fn (f: [B <: {foo: int, ...}, A <: {bar: B}] (A) -> A | B, g) { g(f) };
> fn () {
>   (fn (x) { x })(f)
> }
>   let f : [A <: {foo: int, ...}, B <: {bar: A}, C] (
>     [B_2 <: {foo: int, ...}, A_2 <: {bar: B_2}] (A_2) -> A_2 | B_2,
>     ((B) -> A | B) -> C
>   ) -> C =
>   fn [A <: {foo: int, ...}, B <: {bar: A}, C](
>     f: [B_2 <: {foo: int, ...}, A_2 <: {bar: B_2}] (A_2) -> A_2 | B_2,
>     g: ((B) -> A | B) -> C
>   ) -> C {
>     g(f)
>   };
>   fn [A <: {foo: int, ...}, B <: {bar: A}, C]() ->
>     (({bar: {foo: int, ...}}) -> nothing, ((B) -> A | B) -> C) -> C {
>     (fn [A_2](x: A_2) -> A_2 { x })(f)
>   }
> [A <: {foo: int, ...}, B <: {bar: A}, C] () -> (({bar: {foo: int, ...}}) -> nothing, ((B) -> A | B) -> C) -> C

fn (f: [B <: {foo:int,...}, A <: {bar:B}](A) -> A|B, g) { g(f) }
> fn (f: [B <: {foo: int, ...}, A <: {bar: B}] (A) -> A | B, g) { g(f) }
>   fn [A <: {foo: int, ...}, B <: {bar: A}, C](
>     f: [B_2 <: {foo: int, ...}, A_2 <: {bar: B_2}] (A_2) -> A_2 | B_2,
>     g: ((B) -> A | B) -> C
>   ) -> C {
>     g(f)
>   }
> [A <: {foo: int, ...}, B <: {bar: A}, C] (
>   [B_2 <: {foo: int, ...}, A_2 <: {bar: B_2}] (A_2) -> A_2 | B_2,
>   ((B) -> A | B) -> C
> ) -> C

# wfrig check in ensure_upper_matches
fn[A <: {foo:int}](a: A) { let id = fn(x) { x }; id(a).foo }
> fn [A <: {foo: int}](a: A) { let id = fn (x) { x }; id(a).foo }
>   fn [A <: {foo: int}](a: A) -> int {
>     let id : [B] (B) -> B = fn [B](x: B) -> B { x };
>     id(a).foo
>   }
> [A <: {foo: int}] (A) -> int

# multi upper bounds & specsub (somewhat dodgy)
fn[A <: {foo:int}, B <: {bar:int}](x) -> {a:A, b:{foo:int}|B} {
  let splat = fn(x) { {a:x, b:x} }; splat(x)
}
> fn [A <: {foo: int}, B <: {bar: int}](x) -> {a: A, b: {foo: int} | B} {
>   let splat = fn (x) { {a: x, b: x} };
>   splat(x)
> }
> typechecking error: unimplemented: multi RV upper bounds


# weirdness: non-monotonicity wrt annotations

fn[A <: {foo:int}, B <: {bar:bool}](x) -> {a:{bar:bool}|A, b:{foo:int}|B, c:{foo:int}} {
  {a:x, b:x, c:x}
}
> fn [A <: {foo: int}, B <: {bar: bool}](x) ->
>   {a: {bar: bool} | A, b: {foo: int} | B, c: {foo: int}} {
>   {a: x, b: x, c: x}
> }
> typechecking error: unimplemented: multi RV upper bounds

fn[A <: {foo:int}, B <: {bar:bool}](x) -> {a:{bar:bool}|A, b:{foo:int}|B, c:any} {
  {a:x, b:x, c:x}
}
> fn [A <: {foo: int}, B <: {bar: bool}](x) ->
>   {a: {bar: bool} | A, b: {foo: int} | B, c: any} {
>   {a: x, b: x, c: x}
> }
> typechecking error: unimplemented: multi RV upper bounds


# FIXME: spec_sub_rigid_pos should remove one of the variables here
fn[A <: {foo:int}, B <: {bar:bool}](x) -> {a:{bar:bool}|A, b:{foo:int}|A|B, c:any} {
  {a:x, b:x, c:x}
}
> fn [A <: {foo: int}, B <: {bar: bool}](x) ->
>   {a: {bar: bool} | A, b: {foo: int} | A | B, c: any} {
>   {a: x, b: x, c: x}
> }
> typechecking error: unimplemented: multi RV upper bounds

fn[A](x: any, y:A) { if true {x} else {y} }
> fn [A](x: any, y: A) { if true { x } else { y } }
>   fn [A](x: any, y: A) -> any { if true { x } else { y } }
> [A] (any, A) -> any


fn(x, y, k1, k2, k3) {
  let ch = fn[X](a:X,b:X){if true {a} else {b}};
  let z = ch(x, y)(fn(x){k1(x)});
  (x(k2), y(k3))
}
> fn (x, y, k1, k2, k3) {
>   let ch = fn [X](a: X, b: X) { if true { a } else { b } };
>   let z = ch(x, y)(fn (x) { k1(x) });
>   (x(k2), y(k3))
> }
>   fn [A, B, C, D, E, F](
>     x: (((A) -> B) | C) -> D,
>     y: (((A) -> B) | E) -> F,
>     k1: (A) -> B,
>     k2: C,
>     k3: E
>   ) -> (D, F) {
>     let ch : [X] (X, X) -> X =
>     fn [X](a: X, b: X) -> X { if true { a } else { b } };
>     let z : D | F = ch(x, y)(fn (x: A) -> B { k1(x) });
>     (x(k2), y(k3))
>   }
> [A, B, C, D, E, F] ((((A) -> B) | C) -> D, (((A) -> B) | E) -> F, (A) -> B, C, E) -> (D, F)


# flex_cons_upper freshening matchability bug
fn(x, y) {
  let ch = fn[X](a:X,b:X){if true {a} else {b}};
  let z = ch(x, y).bar;
  (x.bar, y.bar)
}
> fn (x, y) {
>   let ch = fn [X](a: X, b: X) { if true { a } else { b } };
>   let z = ch(x, y).bar;
>   (x.bar, y.bar)
> }
>   fn [A, B](x: {bar: A, ...}, y: {bar: B, ...}) -> (A, B) {
>     let ch : [X] (X, X) -> X =
>     fn [X](a: X, b: X) -> X { if true { a } else { b } };
>     let z : A | B = ch(x, y).bar;
>     (x.bar, y.bar)
>   }
> [A, B] ({bar: A, ...}, {bar: B, ...}) -> (A, B)

# version that actually fails if bug present
fn(y) {
  let ch = fn[X](a:X,b:X){if true {a} else {b}};
  let z = ch({bar:true}, y).bar;
  (y.bar : int)
}
> fn (y) {
>   let ch = fn [X](a: X, b: X) { if true { a } else { b } };
>   let z = ch({bar: true}, y).bar;
>   (y.bar : int)
> }
>   fn [A <: int](y: {bar: A, ...}) -> int {
>     let ch : [X] (X, X) -> X =
>     fn [X](a: X, b: X) -> X { if true { a } else { b } };
>     let z : bool | A = ch({bar: true}, y).bar;
>     (y.bar : int)
>   }
> [A <: int] ({bar: A, ...}) -> int

# same bug, in CPSish style (for nonstrictly positive vars)
# tricky case requiring duplication of non-strictly-covariant vars in flex_cons_upper
fn (x, y, k1, k2, k3) {
  let use = fn [P](a : ((P) -> int) -> int) { a(k1) };
  let ch = fn [X](a : X, b : X) { if true { a } else { b } };
  let z = use(ch(x, y));
  ((x : ((int) -> int) -> int), y)
}
> fn (x, y, k1, k2, k3) {
>   let use = fn [P](a: ((P) -> int) -> int) { a(k1) };
>   let ch = fn [X](a: X, b: X) { if true { a } else { b } };
>   let z = use(ch(x, y));
>   ((x : ((int) -> int) -> int), y)
> }
>   fn [A <: ((any) -> int) -> int](
>     x: ((int) -> int) -> int,
>     y: A,
>     k1: (any) -> int,
>     k2: any,
>     k3: any
>   ) -> (((int) -> int) -> int, A) {
>     let use : [P] (((P) -> int) -> int) -> int =
>     fn [P](a: ((P) -> int) -> int) -> int { a(k1) };
>     let ch : [X] (X, X) -> X =
>     fn [X](a: X, b: X) -> X { if true { a } else { b } };
>     let z : int = use(ch(x, y));
>     ((x : ((int) -> int) -> int), y)
>   }
> [A <: ((any) -> int) -> int] (((int) -> int) -> int, A, (any) -> int, any, any) -> (((int) -> int) -> int, A)


fn (x, y, k) {
  let ch = fn[X](a:X,b:X){if true {a} else {b}};
  let z = ch(x,y)(fn (a) {let z : int = k(a); 1});
  (x(fn(x) { x }), y(fn (x) { x}))
}
> fn (x, y, k) {
>   let ch = fn [X](a: X, b: X) { if true { a } else { b } };
>   let z = ch(x, y)(fn (a) { let z : int = k(a); 1 });
>   (x(fn (x) { x }), y(fn (x) { x }))
> }
>   fn [A, B, C, D, E, F, G](
>     x: ((A) -> int | A | B) -> C,
>     y: ((D) -> int | D | E) -> F,
>     k: (A | D | G) -> int
>   ) -> (C, F) {
>     let ch : [X] (X, X) -> X =
>     fn [X](a: X, b: X) -> X { if true { a } else { b } };
>     let z : C | F =
>     ch(x, y)(fn (a: A | D | G) -> int { let z : int = k(a); 1 });
>     (x(fn [A_2](x: A_2) -> A_2 { x }), y(fn [A_2](x: A_2) -> A_2 { x }))
>   }
> [A, B, C, D, E, F, G] (((A) -> int | A | B) -> C, ((D) -> int | D | E) -> F, (A | D | G) -> int) -> (C, F)

fn  [A](a) -> A { let x = a; x }
> fn [A](a) -> A { let x = a; x }
>   fn [A, B <: A](a: B) -> A { let x : B = a; x }
> [A, B <: A] (B) -> A
> RECHECK: Lang.Check.Fail(_, _)
> 
> ELAB: Lang.Check.Fail(_, _)
> 
> ELABINF: Lang.Check.Fail(_, _)

fn [A](x:A, f:[B <: A](B) -> B) { x }
> fn [A](x: A, f: [B <: A] (B) -> B) { x }
> test:1: Bounds must be constructed types

# Some versions make RHS be {foo:int}, not {foo:int}|A
# This is equivalent but shorter, as A <= {foo:int}.
# Not sure it's worth the effort, though
fn[A <: {foo:int}](x:A, y:{foo:int}) { if true {x} else {y} }
> fn [A <: {foo: int}](x: A, y: {foo: int}) { if true { x } else { y } }
>   fn [A <: {foo: int}](x: A, y: {foo: int}) -> {foo: int} | A {
>     if true {
>       x
>     } else {
>       y
>     }
>   }
> [A <: {foo: int}] (A, {foo: int}) -> {foo: int} | A

# multi RV upper bounds tests
fn[A <: {foo:int}](x) -> (A,{foo:int}) { (x,x) }
> fn [A <: {foo: int}](x) -> (A, {foo: int}) { (x, x) }
> typechecking error: unimplemented: multi RV upper bounds

# ensure_rigvars_present gets this one
fn mkdup[A]() -> (A) -> (A, A) { fn(x) { (x,x) } }
fn[A <: {foo:int}](x,y : A) -> (A,{foo:int}) { let id = mkdup(); let z = id(y); id(x) }
> fn mkdup[A]() -> (A) -> (A, A) {
>   fn (x) {
>     (x, x)
>   }
> }
> fn [A <: {foo: int}](x, y: A) -> (A, {foo: int}) {
>   let id = mkdup();
>   let z = id(y);
>   id(x)
> }
>   fn mkdup[A]() -> (A) -> (A, A) {
>     fn (x) {
>       (x, x)
>     }
>   }
>   fn [A <: {foo: int}](x: A, y: A) -> (A, {foo: int}) {
>     let id : (A) -> (A, A) = mkdup();
>     let z : (A, A) = id(y);
>     id(x)
>   }
> [A <: {foo: int}] (A, A) -> (A, {foo: int})

fn [A,C,B <: int](x) -> (A|C,int|B|C) { (x,x) }
> fn [A, C, B <: int](x) -> (A | C, int | B | C) { (x, x) }
>   fn [A, C, B <: int](x: C) -> (A | C, int | B | C) { (x, x) }
> [A, C, B <: int] (C) -> (A | C, int | B | C)

> STATS: fix: 59, flex: 1919
