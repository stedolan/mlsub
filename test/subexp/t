# poly!
fn[A](x : A) { x }
> fn [A](x: A) { x }
>   fn [A](x: A) -> A { x }
> [A] (A) -> A

fn[A,B](id : [A](A) -> A, (x,y):(A, B)) { (id(y),id(x)) }
> fn [A, B](id: [A] (A) -> A, (x, y): (A, B)) { (id(y), id(x)) }
>   fn [A, B](id: [A_2] (A_2) -> A_2, (x, y): (A, B)) -> (B, A) { (id(y), id(x)) }
> [A, B] ([A_2] (A_2) -> A_2, (A, B)) -> (B, A)

fn(id : [A](A) -> A, (x,y)) { (id(y),id(x)) }
> fn (id: [A] (A) -> A, (x, y)) { (id(y), id(x)) }
>   fn [A, B](id: [A_2] (A_2) -> A_2, (x, y): (B, A)) -> (A, B) { (id(y), id(x)) }
> [A, B] ([A_2] (A_2) -> A_2, (B, A)) -> (A, B)

fn[A](x : A) { if x.cond {x} else {x} }
> fn [A](x: A) { if x.cond{x} else {x} }
> typechecking error: Failure("incompat top <: record")

fn[A <: {cond:bool}](x : A) { if x.cond {x} else {x} }
> fn [A <: {cond: bool}](x: A) { if x.cond{x} else {x} }
>   fn [A <: {cond: bool}](x: A) -> A { if x.cond{x} else {x} }
> [A <: {cond: bool}] (A) -> A

fn(f) { fn[A](x : A) { f(x) } }
> fn (f) { fn [A](x: A) { f(x) } }
>   fn [A](f: (any) -> A) -> [A_2] (A_2) -> A { fn [A_2](x: A_2) -> A { f(x) } }
> [A] ((any) -> A) -> [A_2] (A_2) -> A

# partial poly
fn[A,C](a : A, b, c : C, d) { (a, b, c, d) }
> fn [A, C](a: A, b, c: C, d) { (a, b, c, d) }
>   fn [A, C, B, D](a: A, b: B, c: C, d: D) -> (A, B, C, D) { (a, b, c, d) }
> [A, C, B, D] (A, B, C, D) -> (A, B, C, D)

# real rank1 type (check forall not hoisted)
fn (a) { (fn(x) { (x, fn(x) { x }) })(a) }
> fn (a) { (fn (x) { (x, fn (x) { x }) })(a) }
>   fn [A](a: A) -> (A, [A_2] (A_2) -> A_2) {
>   (fn [A_2](x: A_2) -> (A_2, [A_3] (A_3) -> A_3) {
>   (x, fn [A_3](x: A_3) -> A_3 { x })
>   })(a)
>   }
> [A] (A) -> (A, [A_2] (A_2) -> A_2)

# bidir poly functions

(fn (x: A) { x } : [A] (A) -> A)
> (fn (x: A) { x } : [A] (A) -> A)
> typechecking error: Failure("unknown type A")

(fn (x: bool) { x } : [A] (A) -> A)
> (fn (x: bool) { x } : [A] (A) -> A)
> typechecking error: Failure("incompat top <: bool")

(fn (x: any) { x } : [A] (A) -> A)
> (fn (x: any) { x } : [A] (A) -> A)
> typechecking error: Failure("incompat top <: bot")

(fn[B] (x: B) { x } : [A] (A) -> A)
> (fn [B](x: B) { x } : [A] (A) -> A)
>   (fn [B](x: B) -> B { x } : [A] (A) -> A)
> [A] (A) -> A

(fn[B] (x) { (x : B) } : [A] (A) -> A)
> (fn [B](x) { (x : B) } : [A] (A) -> A)
>   (fn [B](x: B) -> B { (x : B) } : [A] (A) -> A)
> [A] (A) -> A

(fn[B] (x) -> B { (x : B) } : [A] (A) -> A)
> (fn [B](x) -> B { (x : B) } : [A] (A) -> A)
>   (fn [B](x: B) -> B { (x : B) } : [A] (A) -> A)
> [A] (A) -> A

fn[B <: {foo:int}] (x) -> B { x }
> fn [B <: {foo: int}](x) -> B { x }
>   fn [B <: {foo: int}](x: B) -> B { x }
> [B <: {foo: int}] (B) -> B

fn[B <: {foo:int}] (x) { (x : B) }
> fn [B <: {foo: int}](x) { (x : B) }
>   fn [B <: {foo: int}](x: B) -> B { (x : B) }
> [B <: {foo: int}] (B) -> B

(fn() { @true } : [A]() -> bool)
> (fn () { @true } : [A] () -> bool)
>   (fn () { @true } : [A] () -> bool)
> [A] () -> bool

fn(id, x) { (id(x), id(5)) }
> fn (id, x) { (id(x), id(5)) }
>   fn [A, B](id: (int | B) -> A, x: B) -> (A, A) { (id(x), id(5)) }
> [A, B] ((int | B) -> A, B) -> (A, A)

(fn(id, x) { (id(x), id(5)) } : [A]([B](B) -> B, A) -> (A,int))
> (fn (id, x) { (id(x), id(5)) } : [A] ([B] (B) -> B, A) -> (A, int))
>   (fn (id, x) { (id(x), id(5)) } : [A] ([B] (B) -> B, A) -> (A, int))
> [A] ([B] (B) -> B, A) -> (A, int)

fn[A,B](x:A, y:B) { if true { x } else { y } }
> fn [A, B](x: A, y: B) { if true{x} else {y} }
>   fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} }
> [A, B] (A, B) -> A | B

fn[A,B](x : A, y : B) -> A|B { if true { x } else { y } }
> fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} }
>   fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} }
> [A, B] (A, B) -> A | B

let ch = fn[A,B](x : A, y : B) -> A|B { if true { x } else { y } }; ch
> let ch = fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} }; ch
>   let ch : [A, B] (A, B) ->
>   A |
>   B =
>   fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} };
>   ch
> [A, B] (A, B) -> A | B

let ch = fn[A,B](x : A, y : B) -> A|B { if true { x } else { y } }; fn (a,b) { ch(a, b) }
> let ch = fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} }; fn (a, b) { ch(a, b) }
>   let ch : [A, B] (A, B) ->
>   A |
>   B =
>   fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} };
>   fn [A, B](a: A, b: B) -> A |
>   B { ch(a, b) }
> [A, B] (A, B) -> A | B

(fn[A,B](x : A, y : B) -> A|B { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} } : [A] (A, A) -> A)
>   (fn [A, B](x: A, y: B) -> A | B { if true{x} else {y} } : [A] (A, A) -> A)
> [A] (A, A) -> A

(fn[A,B,R](x : A, y : B) -> A|B|R { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B, R](x: A, y: B) -> A | B | R { if true{x} else {y} } : [A] (A, A) -> A)
>   (fn [A, B, R](x: A, y: B) -> A |
>   B |
>   R { if true{x} else {y} } : [A] (A, A) ->
>   A)
> [A] (A, A) -> A

(fn[A,B,R](x : A, y : B) -> R|A { if true { x } else { y } } : [A] (A, A) -> A)
> (fn [A, B, R](x: A, y: B) -> R | A { if true{x} else {y} } : [A] (A, A) -> A)
> typechecking error: Failure("incompat top <: bot")

(fn[A,B,R](x : A, y : B) -> R|A { x } : [A] (A, A) -> A)
> (fn [A, B, R](x: A, y: B) -> R | A { x } : [A] (A, A) -> A)
>   (fn [A, B, R](x: A, y: B) -> R | A { x } : [A] (A, A) -> A)
> [A] (A, A) -> A

# debugging

let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { wid(fn(x){let () = f(5); x.foo}) }
> let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) }; fn (f) { wid(fn (x) { let () = f(5); x.foo }) }
>   let wid : ([B] ({foo: B}) -> B) ->
>   int =
>   fn (id: [B] ({foo: B}) -> B) -> int { id({foo: 5}) };
>   fn [A <: ()](f: (int) -> A) -> int { wid(fn (x) { let () : A = f(5); x.foo }) }
> [A <: ()] ((int) -> A) -> int


# making this work requires an annotation on f, due to hoisting
# (by design, but a bit weird)
let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){let () = f(x); x.foo}); wid(g) }
> let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) }; fn (f) { let g = (fn (x) { let () = f(x); x.foo }); wid(g) }
> typechecking error: Failure("incompat top <: bot")

# works in checking mode (bidir)
# FIXME: [A <: ()] is correct, but not great
let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f) { wid(fn(x){let () = f(x); x.foo}) }
> let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) }; fn (f) { wid(fn (x) { let () = f(x); x.foo }) }
>   let wid : ([B] ({foo: B}) -> B) ->
>   int =
>   fn (id: [B] ({foo: B}) -> B) -> int { id({foo: 5}) };
>   fn [A <: ()](f: ({foo: any}) -> A) -> int {
>   wid(fn (x) { let () : A = f(x); x.foo })
>   }
> [A <: ()] (({foo: any}) -> A) -> int

let wid = fn (id: [B]({foo:B}) -> B) { id({foo:5}) }; fn(f : (any) -> ()) { wid(fn(x){let () = f(x); x.foo}) }
> let wid = fn (id: [B] ({foo: B}) -> B) { id({foo: 5}) }; fn (f: (any) -> ()) { wid(fn (x) { let () = f(x); x.foo }) }
>   let wid : ([B] ({foo: B}) -> B) ->
>   int =
>   fn (id: [B] ({foo: B}) -> B) -> int { id({foo: 5}) };
>   fn (f: (any) -> ()) -> int { wid(fn (x) { let () : () = f(x); x.foo }) }
> ((any) -> ()) -> int


let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f) { let g = (fn(x){let z = f({bar:x}); x.foo}); wid(g) }
> let wid = fn (id: [B, A <: {foo: B}] (A) -> B) { id({foo: 5}) };
> fn (f) { let g = (fn (x) { let z = f({bar: x}); x.foo }); wid(g) }
> typechecking error: Failure("incompat top <: bot")

let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f) { wid(fn(x){let z = f({bar:x}); x.foo}) }
> let wid = fn (id: [B, A <: {foo: B}] (A) -> B) { id({foo: 5}) }; fn (f) { wid(fn (x) { let z = f({bar: x}); x.foo }) }
>   let wid : ([B, A <: {foo: B}] (A) -> B) ->
>   int =
>   fn (id: [B, A <: {foo: B}] (A) -> B) -> int { id({foo: 5}) };
>   fn [A](f: ({bar: {foo: any}}) -> A) -> int {
>   wid(fn (x) { let z : A = f({bar: x}); x.foo })
>   }
> [A] (({bar: {foo: any}}) -> A) -> int

let wid = fn (id: [B,A <: {foo:B}](A) -> B) { id({foo:5}) }; fn(f : (any) -> string) { wid(fn(x){let z = f({bar:x}); x.foo}) }
> let wid = fn (id: [B, A <: {foo: B}] (A) -> B) { id({foo: 5}) };
> fn (f: (any) -> string) { wid(fn (x) { let z = f({bar: x}); x.foo }) }
>   let wid : ([B, A <: {foo: B}] (A) -> B) ->
>   int =
>   fn (id: [B, A <: {foo: B}] (A) -> B) -> int { id({foo: 5}) };
>   fn (f: (any) -> string) -> int {
>   wid(fn (x) { let z : string = f({bar: x}); x.foo })
>   }
> ((any) -> string) -> int

let id = fn(x) { x }; fn () { (id (id), id) }
> let id = fn (x) { x }; fn () { (id(id), id) }
>   let id : [A] (A) -> A = fn [A](x: A) -> A { x };
>   fn [A]() -> ((A) -> A, [A_2] (A_2) -> A_2) { (id(id), id) }
> [A] () -> ((A) -> A, [A_2] (A_2) -> A_2)


fn(f) { fn(id: [A] (A) -> A) { let x = f(id); id(1) } }
> fn (f) { fn (id: [A] (A) -> A) { let x = f(id); id(1) } }
>   fn [A, B](f: ((B) -> B) -> A) -> ([A_2] (A_2) -> A_2) ->
>   int { fn (id: [A_2] (A_2) -> A_2) -> int { let x : A = f(id); id(1) } }
> [A, B] (((B) -> B) -> A) -> ([A_2] (A_2) -> A_2) -> int

fn(f) { fn(id: [A] (A) -> A) { id(fn(y) { let x = f(y); y }) } }
> fn (f) { fn (id: [A] (A) -> A) { id(fn (y) { let x = f(y); y }) } }
>   fn [A, B](f: (A) -> B) -> ([A_2] (A_2) -> A_2) ->
>   (A) ->
>   A {
>   fn (id: [A_2] (A_2) -> A_2) -> (A) ->
>   A { id(fn (y: A) -> A { let x : B = f(y); y }) }
>   }
> [A, B] ((A) -> B) -> ([A_2] (A_2) -> A_2) -> (A) -> A


(fn(x) {(fn(y){y})(x)} : [A] (A) -> A)
> (fn (x) { (fn (y) { y })(x) } : [A] (A) -> A)
>   (fn (x) { (fn [A](y: A) -> A { y })(x) } : [A] (A) -> A)
> [A] (A) -> A

let id = fn(y) { y }; (fn[A](x : A) {id(x)})
> let id = fn (y) { y }; (fn [A](x: A) { id(x) })
>   let id : [A] (A) -> A = fn [A](y: A) -> A { y }; (fn [A](x: A) -> A { id(x) })
> [A] (A) -> A

let id = fn(y) { y }; (fn(x) {id(x)} : [A] (A) -> A)
> let id = fn (y) { y }; (fn (x) { id(x) } : [A] (A) -> A)
>   let id : [A] (A) -> A = fn [A](y: A) -> A { y };
>   (fn (x) { id(x) } : [A] (A) -> A)
> [A] (A) -> A


fn[A,B](x : [X <: B](X|A) -> X) -> (A) -> B { x }
> fn [A, B](x: [X <: B] (X | A) -> X) -> (A) -> B { x }
> typechecking error: Failure("rig var bounds must be Tcons")

fn[A,B](x : [X <: B](X|A) -> X) -> (A) -> A|B { x }
> fn [A, B](x: [X <: B] (X | A) -> X) -> (A) -> A | B { x }
> typechecking error: Failure("rig var bounds must be Tcons")

# wtf:
# fn[A,B,A <: B](x : [X, X <: A, X :> B](X) -> X) -> [X <: A, Y :> B, X <: Y](X) -> Y { x }
# > parser failure: bad parse


# some invalid types that should be rejected because of bad joins
# FIXME: reject these at an appropriate position

(@bot : [A] [B] ({foo: B} | A))
> (@bot : [A] [B] ({foo: B} | A))
> File "src/typedefs.ml", line 725, characters 5-11: Assertion failed
> Raised at Lang__Typedefs.wf_var in file "src/typedefs.ml", line 725, characters 5-56
> Called from Stdlib__map.Make.mapi in file "map.ml", line 312, characters 19-24
> Called from Lang__Tuple_fields.map_fields in file "src/tuple_fields.ml", line 56, characters 21-65
> Called from Lang__Typedefs.map_head in file "src/typedefs.ml", line 96, characters 28-68
> Called from Lang__Typedefs.wf_typ in file "src/typedefs.ml", line 736, characters 5-115
> Called from Lang__Check.check in file "src/check.ml", line 177, characters 2-16
> Called from Lang__Check.infer' in file "src/check.ml", line 269, characters 17-30
> Called from Lang__Check.infer in file "src/check.ml", line 261, characters 17-29
> Called from Lang__Check.elab_gen in file "src/check.ml", line 131, characters 27-34
> Called from Dune__exe__Test_runner.run_cmd in file "test/test_runner.ml", line 54, characters 17-75

(@bot : [A <: [B]int]int)
> (@bot : [A <: [B] int] int)
> typechecking error: Failure("rig var bounds must be Tcons")

# bug in substn_ntyp
fn[A](id: [B](A) -> int) { id }
> fn [A](id: [B] (A) -> int) { id }
>   fn [A](id: [B] (A) -> int) -> [B] (A) -> int { id }
> [A] ([B] (A) -> int) -> [B] (A) -> int

fn[A](id: [B](A, B) -> int, x:A) -> int {id(x,1)}
> fn [A](id: [B] (A, B) -> int, x: A) -> int { id(x, 1) }
>   fn [A](id: [B] (A, B) -> int, x: A) -> int { id(x, 1) }
> [A] ([B] (A, B) -> int, A) -> int

# If this fails someday due to unannoted x/ret, that's fine
fn[A](id: [B](A, B) -> (A, B), x){id(x,1)}
> fn [A](id: [B] (A, B) -> (A, B), x) { id(x, 1) }
>   fn [A](id: [B] (A, B) -> (A, B), x: A) -> (A, int) { id(x, 1) }
> [A] ([B] (A, B) -> (A, B), A) -> (A, int)

(fn[A](id: (A) -> (nothing)){id})(fn(a){a})
> (fn [A](id: (A) -> (nothing)) { id })(fn (a) { a })
>   (fn [A](id: (A) -> nothing) -> (A) -> nothing { id })(fn (a) { a })
> (nothing) -> nothing

# another bug
let f = fn[A](id: (A) -> A){1}; f(fn(a){a})
> let f = fn [A](id: (A) -> A) { 1 }; f(fn (a) { a })
>   let f : [A] ((A) -> A) -> int = fn [A](id: (A) -> A) -> int { 1 };
>   f(fn (a) { a })
> int

let f = fn[A](id: [B](A, B) -> (A, B), x:A){id(x,1)}; fn(z){ f(fn(a,b){(a,b)}, if z.cond {z.a}else{z.b}) }
> let f = fn [A](id: [B] (A, B) -> (A, B), x: A) { id(x, 1) };
> fn (z) { f(fn (a, b) { (a, b) }, if z.cond{z.a} else {z.b}) }
>   let f : [A] ([B] (A, B) -> (A, B), A) ->
>   (A, int) =
>   fn [A](id: [B] (A, B) -> (A, B), x: A) -> (A, int) { id(x, 1) };
>   fn [A](z: {cond: bool, a: A, b: A, ...}) -> (A, int) {
>   f(fn (a, b) { (a, b) }, if z.cond{z.a} else {z.b})
>   }
> [A] ({cond: bool, a: A, b: A, ...}) -> (A, int)

# test match_simple_typ with complex upper bound
let appf = fn[B, C, A <: (B) -> C](f : A, x : B) { f(x) }; fn() { appf(fn(x) { x }, 1) }
> let appf = fn [B, C, A <: (B) -> C](f: A, x: B) { f(x) }; fn () { appf(fn (x) { x }, 1) }
>   let appf : [B, C, A <: (B) -> C] (A, B) ->
>   C =
>   fn [B, C, A <: (B) -> C](f: A, x: B) -> C { f(x) };
>   fn () -> int { appf(fn [A](x: A) -> A { x }, 1) }
> () -> int

let appf = fn[B, C, A <: (B) -> C](f : A, x : B) { f(x) }; fn() { appf(fn(x) { 1 }, 1) }
> let appf = fn [B, C, A <: (B) -> C](f: A, x: B) { f(x) }; fn () { appf(fn (x) { 1 }, 1) }
>   let appf : [B, C, A <: (B) -> C] (A, B) ->
>   C =
>   fn [B, C, A <: (B) -> C](f: A, x: B) -> C { f(x) };
>   fn () -> int { appf(fn (x: any) -> int { 1 }, 1) }
> () -> int

let appf = fn[B, C, A <: (B) -> C](f : A, x : B) { f(x) }; fn() { appf(3, 1) }
> let appf = fn [B, C, A <: (B) -> C](f: A, x: B) { f(x) }; fn () { appf(3, 1) }
> typechecking error: Failure("incompat int <: func")
